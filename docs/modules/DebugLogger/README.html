<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>DebugLogger モジュール </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="DebugLogger モジュール ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/EndlessShirafu/VaNilla/blob/feature/apply-net10-and-csharp14/Documents/docfx/modules/DebugLogger/README.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="debuglogger-モジュール">DebugLogger モジュール</h1>

<p>DebugLoggerモジュールは、VaNillaエンジンでプラットフォーム非依存なログ出力機能を提供するシステムです。Unity等の特定のフレームワークに依存せず、デバッグ情報、警告、エラーメッセージを統一されたインターフェースで出力できます。</p>
<h2 id="概要">概要</h2>
<p>このモジュールは以下の機能を提供します：</p>
<ul>
<li><strong>プラットフォーム非依存</strong>: Unity等のフレームワークに依存しない汎用ログシステム</li>
<li><strong>ログレベル管理</strong>: 通常ログ、警告、エラーの3段階ログレベル</li>
<li><strong>呼び出し元自動追跡</strong>: CallerMemberName属性による自動的なファイル・行番号記録</li>
<li><strong>アサート機能</strong>: 条件チェックによるデバッグ支援</li>
<li><strong>プラガブル設計</strong>: ログ出力先の差し替え可能な設計</li>
<li><strong>ネイティブ統合</strong>: Native.LoggerNativeによる各プラットフォーム対応</li>
</ul>
<h2 id="実装状況">実装状況</h2>
<p>✅ <strong>完了</strong>: 全てのログ機能が実装済みです。</p>
<h2 id="apiリファレンス">APIリファレンス</h2>
<p>詳細なAPIドキュメントは<a href="https://endlessshirafu.github.io/VaNillaEngineApiDocuments/api/VaNilla.Debug.html">VaNilla DebugLogger APIリファレンス</a>をご覧ください。</p>
<h2 id="主要コンポーネント">主要コンポーネント</h2>
<h3 id="1-logger静的ログapi">1. Logger（静的ログAPI）</h3>
<p>アプリケーションから呼び出される統一ログインターフェースです。</p>
<pre><code class="lang-csharp">public static class Logger
{
    // 基本ログ出力
    public static void Log(object message, [CallerFilePath] string callerFile = &quot;&quot;, [CallerLineNumber] int callerLine = 0);
    public static void LogWarning(object message, [CallerFilePath] string callerFile = &quot;&quot;, [CallerLineNumber] int callerLine = 0);
    public static void LogError(object message, [CallerFilePath] string callerFile = &quot;&quot;, [CallerLineNumber] int callerLine = 0);
    
    // デバッグ機能
    public static void Assert(bool condition);
    public static void ClearLog();
    
    // ログ実装差し替え
    public static void Set(ILogger logger);
}
</code></pre>
<h3 id="2-iloggerログ実装インターフェース">2. ILogger（ログ実装インターフェース）</h3>
<p>実際のログ出力処理を定義するインターフェースです。</p>
<pre><code class="lang-csharp">public interface ILogger
{
    // ログ出力機能
    void Log(object message, string callerFile, int callerLine);
    void LogWarning(object message, string callerFile, int callerLine);
    void LogError(object message, string callerFile, int callerLine);
    
    // デバッグ機能
    void Assert(bool condition);
    void ClearLog();
}
</code></pre>
<h2 id="使用方法">使用方法</h2>
<h3 id="基本的なログ出力">基本的なログ出力</h3>
<pre><code class="lang-csharp">public class BasicLoggingExample
{
    public void DemonstrateBasicLogging()
    {
        // 通常ログ
        VaNilla.Debug.Logger.Log(&quot;Application started&quot;);
        VaNilla.Debug.Logger.Log($&quot;Current time: {DateTime.Now}&quot;);
        
        // 警告ログ
        VaNilla.Debug.Logger.LogWarning(&quot;This is a warning message&quot;);
        VaNilla.Debug.Logger.LogWarning(&quot;Performance warning: FPS dropped below 30&quot;);
        
        // エラーログ
        VaNilla.Debug.Logger.LogError(&quot;This is an error message&quot;);
        VaNilla.Debug.Logger.LogError(&quot;Failed to load texture: player.png&quot;);
        
        // 任意のオブジェクトをログ出力
        var position = new Vector2(100, 200);
        VaNilla.Debug.Logger.Log($&quot;Player position: {position}&quot;);
    }
}
</code></pre>
<h3 id="ゲーム開発での実用ログ">ゲーム開発での実用ログ</h3>
<pre><code class="lang-csharp">public class GameLoggingExample : IExpresserComponent
{
    private int frameCount = 0;
    private float lastLogTime = 0.0f;
    
    public bool Execute(Object object__, in VaNilla.Time.Time current_time)
    {
        frameCount++;
        
        // 1秒毎にパフォーマンス情報をログ出力
        if (current_time.current_time - lastLogTime &gt;= 1.0f)
        {
            float fps = frameCount / (current_time.current_time - lastLogTime);
            VaNilla.Debug.Logger.Log($&quot;FPS: {fps:F1}, Frame: {frameCount}&quot;);
            
            // FPS警告
            if (fps &lt; 30.0f)
            {
                VaNilla.Debug.Logger.LogWarning($&quot;Low FPS detected: {fps:F1}&quot;);
            }
            
            frameCount = 0;
            lastLogTime = current_time.current_time;
        }
        
        return true;
    }
    
    // IExpresserComponent実装
    public bool SetUp(Object object__)
    {
        VaNilla.Debug.Logger.Log(&quot;GameLoggingExample component initialized&quot;);
        return true;
    }
    
    public void TearDown(Object object__)
    {
        VaNilla.Debug.Logger.Log(&quot;GameLoggingExample component destroyed&quot;);
    }
    
    public bool Active { get; set; } = true;
    public Execute.ExecuteType ExecuteType { get; set; }
}
</code></pre>
<h3 id="アサート機能の活用">アサート機能の活用</h3>
<pre><code class="lang-csharp">public class AssertExample
{
    public void ValidatePlayerState(PlayerController player)
    {
        // プレイヤーの状態をアサート
        VaNilla.Debug.Logger.Assert(player != null);
        
        if (player != null)
        {
            // HPが有効範囲内かアサート
            VaNilla.Debug.Logger.Assert(player.HP &gt;= 0 &amp;&amp; player.HP &lt;= player.MaxHP);
            
            // 位置が画面内かアサート
            VaNilla.Debug.Logger.Assert(player.Position.X &gt;= 0 &amp;&amp; player.Position.X &lt;= 800);
            VaNilla.Debug.Logger.Assert(player.Position.Y &gt;= 0 &amp;&amp; player.Position.Y &lt;= 600);
            
            VaNilla.Debug.Logger.Log($&quot;Player state validated: HP={player.HP}/{player.MaxHP}, Pos={player.Position}&quot;);
        }
    }
    
    public void ValidateGameConfig(GameConfig config)
    {
        VaNilla.Debug.Logger.Assert(config.TargetFPS &gt; 0);
        VaNilla.Debug.Logger.Assert(config.ScreenWidth &gt; 0 &amp;&amp; config.ScreenHeight &gt; 0);
        VaNilla.Debug.Logger.Assert(!string.IsNullOrEmpty(config.GameTitle));
        
        if (config.TargetFPS &lt; 30)
        {
            VaNilla.Debug.Logger.LogWarning($&quot;Low target FPS configured: {config.TargetFPS}&quot;);
        }
        
        VaNilla.Debug.Logger.Log(&quot;Game configuration validated successfully&quot;);
    }
}
</code></pre>
<h3 id="エラーハンドリングとログ">エラーハンドリングとログ</h3>
<pre><code class="lang-csharp">public class ErrorHandlingExample
{
    public bool LoadTexture(string filePath)
    {
        try
        {
            VaNilla.Debug.Logger.Log($&quot;Loading texture: {filePath}&quot;);
            
            // テクスチャロード処理（疑似コード）
            if (string.IsNullOrEmpty(filePath))
            {
                VaNilla.Debug.Logger.LogError(&quot;Texture file path is null or empty&quot;);
                return false;
            }
            
            if (!System.IO.File.Exists(filePath))
            {
                VaNilla.Debug.Logger.LogError($&quot;Texture file not found: {filePath}&quot;);
                return false;
            }
            
            // ロード成功
            VaNilla.Debug.Logger.Log($&quot;Texture loaded successfully: {filePath}&quot;);
            return true;
        }
        catch (System.Exception ex)
        {
            VaNilla.Debug.Logger.LogError($&quot;Exception while loading texture: {ex.Message}&quot;);
            return false;
        }
    }
    
    public void HandleNetworkError(int errorCode, string errorMessage)
    {
        switch (errorCode)
        {
            case 404:
                VaNilla.Debug.Logger.LogWarning($&quot;Resource not found: {errorMessage}&quot;);
                break;
            case 500:
                VaNilla.Debug.Logger.LogError($&quot;Server error: {errorMessage}&quot;);
                break;
            case 0:
                VaNilla.Debug.Logger.LogError($&quot;Network connection failed: {errorMessage}&quot;);
                break;
            default:
                VaNilla.Debug.Logger.LogError($&quot;Unknown network error [{errorCode}]: {errorMessage}&quot;);
                break;
        }
    }
}
</code></pre>
<h2 id="ゲーム開発での実用例">ゲーム開発での実用例</h2>
<h3 id="デバッグ情報表示システム">デバッグ情報表示システム</h3>
<pre><code class="lang-csharp">public class DebugInfoDisplay : IExpresserComponent
{
    private bool isDebugEnabled = false;
    private float updateInterval = 0.1f;
    private float lastUpdateTime = 0.0f;
    
    public bool Execute(Object object__, in VaNilla.Time.Time current_time)
    {
        // F1キーでデバッグ表示切り替え
        if (KeyboardInput.KeyboardInput.IsKeyDown(Key.F1))
        {
            ToggleDebugDisplay();
        }
        
        if (isDebugEnabled &amp;&amp; current_time.current_time - lastUpdateTime &gt;= updateInterval)
        {
            DisplayDebugInfo(current_time);
            lastUpdateTime = current_time.current_time;
        }
        
        return true;
    }
    
    private void ToggleDebugDisplay()
    {
        isDebugEnabled = !isDebugEnabled;
        VaNilla.Debug.Logger.Log($&quot;Debug display: {(isDebugEnabled ? &quot;ON&quot; : &quot;OFF&quot;)}&quot;);
        
        if (!isDebugEnabled)
        {
            VaNilla.Debug.Logger.ClearLog();
        }
    }
    
    private void DisplayDebugInfo(VaNilla.Time.Time time)
    {
        // システム情報
        VaNilla.Debug.Logger.Log($&quot;=== Debug Info ===&quot;);
        VaNilla.Debug.Logger.Log($&quot;Time: {time.current_time:F2}s&quot;);
        VaNilla.Debug.Logger.Log($&quot;Delta: {time.DeltaTime:F4}s&quot;);
        VaNilla.Debug.Logger.Log($&quot;FPS: {1.0f / time.DeltaTime:F1}&quot;);
        
        // メモリ情報
        long memoryUsage = System.GC.GetTotalMemory(false);
        VaNilla.Debug.Logger.Log($&quot;Memory: {memoryUsage / 1024 / 1024}MB&quot;);
        
        // オブジェクト数
        int objectCount = ObjectExecutor.GetActiveObjectCount();
        VaNilla.Debug.Logger.Log($&quot;Objects: {objectCount}&quot;);
    }
    
    // IExpresserComponent実装
    public bool SetUp(Object object__) =&gt; true;
    public void TearDown(Object object__) { }
    public bool Active { get; set; } = true;
    public Execute.ExecuteType ExecuteType { get; set; }
}
</code></pre>
<h3 id="プレイヤー状態監視システム">プレイヤー状態監視システム</h3>
<pre><code class="lang-csharp">public class PlayerStateMonitor : IExpresserComponent
{
    private PlayerController player;
    private Vector2 lastPosition;
    private float lastHP;
    private bool wasGrounded = true;
    
    public bool SetUp(Object object__)
    {
        player = object__.GetExpresserComponent&lt;PlayerController&gt;();
        if (player != null)
        {
            lastPosition = player.Position;
            lastHP = player.HP;
            VaNilla.Debug.Logger.Log(&quot;PlayerStateMonitor initialized&quot;);
        }
        else
        {
            VaNilla.Debug.Logger.LogError(&quot;PlayerController not found&quot;);
        }
        return true;
    }
    
    public bool Execute(Object object__, in VaNilla.Time.Time current_time)
    {
        if (player == null) return false;
        
        // 位置変化の監視
        MonitorPositionChanges();
        
        // HP変化の監視
        MonitorHealthChanges();
        
        // 状態変化の監視
        MonitorStateChanges();
        
        // 異常状態の検知
        DetectAnomalies();
        
        return true;
    }
    
    private void MonitorPositionChanges()
    {
        Vector2 currentPosition = player.Position;
        float distance = (currentPosition - lastPosition).GetLength();
        
        if (distance &gt; 500.0f) // 1フレームで500ピクセル以上移動
        {
            VaNilla.Debug.Logger.LogWarning($&quot;Large position change detected: {distance:F1} pixels&quot;);
            VaNilla.Debug.Logger.LogWarning($&quot;From {lastPosition} to {currentPosition}&quot;);
        }
        
        lastPosition = currentPosition;
    }
    
    private void MonitorHealthChanges()
    {
        if (player.HP != lastHP)
        {
            float hpChange = player.HP - lastHP;
            if (hpChange &lt; 0)
            {
                VaNilla.Debug.Logger.LogWarning($&quot;Player took damage: {-hpChange} HP (Now: {player.HP}/{player.MaxHP})&quot;);
            }
            else
            {
                VaNilla.Debug.Logger.Log($&quot;Player healed: +{hpChange} HP (Now: {player.HP}/{player.MaxHP})&quot;);
            }
            
            lastHP = player.HP;
        }
    }
    
    private void MonitorStateChanges()
    {
        // 接地状態の変化
        if (player.IsGrounded != wasGrounded)
        {
            if (player.IsGrounded)
            {
                VaNilla.Debug.Logger.Log(&quot;Player landed&quot;);
            }
            else
            {
                VaNilla.Debug.Logger.Log(&quot;Player jumped/fell&quot;);
            }
            wasGrounded = player.IsGrounded;
        }
    }
    
    private void DetectAnomalies()
    {
        // HP異常値チェック
        if (player.HP &lt; 0)
        {
            VaNilla.Debug.Logger.LogError($&quot;Player HP is negative: {player.HP}&quot;);
        }
        
        if (player.HP &gt; player.MaxHP)
        {
            VaNilla.Debug.Logger.LogError($&quot;Player HP exceeds maximum: {player.HP}/{player.MaxHP}&quot;);
        }
        
        // 位置異常値チェック
        if (player.Position.X &lt; -1000 || player.Position.X &gt; 2000 || 
            player.Position.Y &lt; -1000 || player.Position.Y &gt; 2000)
        {
            VaNilla.Debug.Logger.LogError($&quot;Player position out of bounds: {player.Position}&quot;);
        }
    }
    
    public void TearDown(Object object__)
    {
        VaNilla.Debug.Logger.Log(&quot;PlayerStateMonitor destroyed&quot;);
    }
    
    public bool Active { get; set; } = true;
    public Execute.ExecuteType ExecuteType { get; set; }
}
</code></pre>
<h3 id="ネットワーク通信ログ">ネットワーク通信ログ</h3>
<pre><code class="lang-csharp">public class NetworkLogger
{
    public static void LogConnection(string serverAddress, int port)
    {
        VaNilla.Debug.Logger.Log($&quot;Connecting to server: {serverAddress}:{port}&quot;);
    }
    
    public static void LogConnectionSuccess(string serverAddress)
    {
        VaNilla.Debug.Logger.Log($&quot;Successfully connected to: {serverAddress}&quot;);
    }
    
    public static void LogConnectionFailure(string serverAddress, string reason)
    {
        VaNilla.Debug.Logger.LogError($&quot;Failed to connect to {serverAddress}: {reason}&quot;);
    }
    
    public static void LogPacketSent(string packetType, int size)
    {
        VaNilla.Debug.Logger.Log($&quot;Sent packet: {packetType} ({size} bytes)&quot;);
    }
    
    public static void LogPacketReceived(string packetType, int size)
    {
        VaNilla.Debug.Logger.Log($&quot;Received packet: {packetType} ({size} bytes)&quot;);
    }
    
    public static void LogLatency(float pingTime)
    {
        if (pingTime &gt; 100.0f)
        {
            VaNilla.Debug.Logger.LogWarning($&quot;High latency detected: {pingTime:F1}ms&quot;);
        }
        else
        {
            VaNilla.Debug.Logger.Log($&quot;Ping: {pingTime:F1}ms&quot;);
        }
    }
    
    public static void LogDisconnection(string reason)
    {
        VaNilla.Debug.Logger.LogWarning($&quot;Disconnected from server: {reason}&quot;);
    }
}
</code></pre>
<h3 id="カスタムlogger実装">カスタムLogger実装</h3>
<pre><code class="lang-csharp">public class FileLogger : ILogger
{
    private string logFilePath;
    private object lockObject = new object();
    
    public FileLogger(string filePath)
    {
        logFilePath = filePath;
        
        // ログファイル初期化
        try
        {
            System.IO.File.WriteAllText(logFilePath, $&quot;=== VaNilla Game Log Started at {DateTime.Now} ===\n&quot;);
        }
        catch (System.Exception ex)
        {
            // デフォルトログに出力
            Console.WriteLine($&quot;Failed to initialize log file: {ex.Message}&quot;);
        }
    }
    
    public void Log(object message, string callerFile, int callerLine)
    {
        WriteLog(&quot;INFO&quot;, message, callerFile, callerLine);
    }
    
    public void LogWarning(object message, string callerFile, int callerLine)
    {
        WriteLog(&quot;WARN&quot;, message, callerFile, callerLine);
    }
    
    public void LogError(object message, string callerFile, int callerLine)
    {
        WriteLog(&quot;ERROR&quot;, message, callerFile, callerLine);
    }
    
    public void Assert(bool condition)
    {
        if (!condition)
        {
            WriteLog(&quot;ASSERT&quot;, &quot;Assertion failed!&quot;, &quot;&quot;, 0);
            
#if DEBUG
            System.Diagnostics.Debugger.Break();
#endif
        }
    }
    
    public void ClearLog()
    {
        lock (lockObject)
        {
            try
            {
                System.IO.File.WriteAllText(logFilePath, $&quot;=== Log Cleared at {DateTime.Now} ===\n&quot;);
            }
            catch (System.Exception ex)
            {
                Console.WriteLine($&quot;Failed to clear log file: {ex.Message}&quot;);
            }
        }
    }
    
    private void WriteLog(string level, object message, string callerFile, int callerLine)
    {
        lock (lockObject)
        {
            try
            {
                string fileName = System.IO.Path.GetFileName(callerFile);
                string timestamp = DateTime.Now.ToString(&quot;HH:mm:ss.fff&quot;);
                string logEntry = $&quot;[{timestamp}] [{level}] {message}&quot;;
                
                if (!string.IsNullOrEmpty(fileName))
                {
                    logEntry += $&quot; ({fileName}:{callerLine})&quot;;
                }
                
                logEntry += &quot;\n&quot;;
                
                System.IO.File.AppendAllText(logFilePath, logEntry);
                
                // コンソールにも出力
                Console.Write(logEntry);
            }
            catch (System.Exception ex)
            {
                Console.WriteLine($&quot;Failed to write log: {ex.Message}&quot;);
            }
        }
    }
}

// カスタムLoggerの使用例
public class CustomLoggerExample
{
    public static void SetupCustomLogger()
    {
        // ファイルロガーに切り替え
        var fileLogger = new FileLogger(&quot;game_log.txt&quot;);
        VaNilla.Debug.Logger.Set(fileLogger);
        
        VaNilla.Debug.Logger.Log(&quot;Custom file logger initialized&quot;);
    }
}
</code></pre>
<h3 id="デバッグビルド用条件付きログ">デバッグビルド用条件付きログ</h3>
<pre><code class="lang-csharp">public static class DebugLog
{
    [System.Diagnostics.Conditional(&quot;DEBUG&quot;)]
    public static void Log(object message)
    {
        VaNilla.Debug.Logger.Log($&quot;[DEBUG] {message}&quot;);
    }
    
    [System.Diagnostics.Conditional(&quot;DEBUG&quot;)]
    public static void LogPerformance(string operation, float timeMs)
    {
        if (timeMs &gt; 16.67f) // 60FPS基準
        {
            VaNilla.Debug.Logger.LogWarning($&quot;[PERF] {operation} took {timeMs:F2}ms (&gt;16.67ms)&quot;);
        }
        else
        {
            VaNilla.Debug.Logger.Log($&quot;[PERF] {operation} took {timeMs:F2}ms&quot;);
        }
    }
    
    [System.Diagnostics.Conditional(&quot;DEBUG&quot;)]
    public static void LogMemory(string context)
    {
        long memoryBefore = System.GC.GetTotalMemory(false);
        System.GC.Collect();
        long memoryAfter = System.GC.GetTotalMemory(true);
        
        VaNilla.Debug.Logger.Log($&quot;[MEMORY] {context}: {memoryBefore / 1024}KB -&gt; {memoryAfter / 1024}KB&quot;);
    }
}

// 使用例
public class PerformanceMonitor
{
    public void MeasureOperation()
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        // 重い処理
        PerformHeavyOperation();
        
        stopwatch.Stop();
        DebugLog.LogPerformance(&quot;Heavy Operation&quot;, (float)stopwatch.Elapsed.TotalMilliseconds);
    }
    
    private void PerformHeavyOperation()
    {
        DebugLog.Log(&quot;Starting heavy operation&quot;);
        
        // 処理内容...
        
        DebugLog.Log(&quot;Heavy operation completed&quot;);
    }
}
</code></pre>
<h2 id="パフォーマンス考慮事項">パフォーマンス考慮事項</h2>
<ul>
<li><strong>CallerMemberName属性</strong>: コンパイル時に展開されるため実行時コストなし</li>
<li><strong>プラガブル設計</strong>: ILogger実装による柔軟な出力先変更</li>
<li><strong>ネイティブ統合</strong>: プラットフォーム最適化されたログ出力</li>
<li><strong>条件付きコンパイル</strong>: DEBUGビルドでのみ有効なログ機能</li>
</ul>
<h2 id="注意事項">注意事項</h2>
<h3 id="パフォーマンス影響">パフォーマンス影響</h3>
<ul>
<li>ログ出力は文字列処理を伴うため頻繁な呼び出しは避ける</li>
<li>リリースビルドでは条件付きコンパイルの活用を推奨</li>
</ul>
<h3 id="スレッドセーフティ">スレッドセーフティ</h3>
<ul>
<li>Native.LoggerNativeの実装に依存</li>
<li>カスタムILogger実装時はスレッドセーフティを考慮</li>
</ul>
<h3 id="ファイル出力">ファイル出力</h3>
<ul>
<li>ファイルパスの存在チェックと書き込み権限の確認が必要</li>
<li>ディスク容量不足への対処が重要</li>
</ul>
<h2 id="依存関係">依存関係</h2>
<ul>
<li><strong>Native.LoggerNative</strong> - ネイティブ層ログ実装</li>
<li><strong>System.Runtime.CompilerServices</strong> - CallerMemberName属性</li>
<li><strong>System.IO</strong> - ファイル出力（カスタム実装時）</li>
</ul>
<h2 id="関連モジュール">関連モジュール</h2>
<ul>
<li><a href="../SupremeArbiter/README.html">SupremeArbiter</a> - エンジン全体のデバッグ制御</li>
<li><a href="../DebugUtil/README.html">DebugUtil</a> - その他のデバッグ支援機能</li>
<li><strong>Native</strong> - プラットフォーム固有の実装</li>
</ul>
<p>このモジュールにより、VaNillaエンジンで統一されたプラットフォーム非依存なログ出力システムが提供されます。</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/EndlessShirafu/VaNilla/blob/feature/apply-net10-and-csharp14/Documents/docfx/modules/DebugLogger/README.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>OffScreenRenderer </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="OffScreenRenderer ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/EndlessShirafu/VaNilla/blob/develop/Documents/docfx/modules/OffScreenRenderer/README.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="offscreenrenderer">OffScreenRenderer</h1>

<p>オフスクリーンレンダリング機能を提供するモジュールです。テクスチャへの描画、ポストプロセッシング、マルチパスレンダリングなどの高度な描画技術を実現します。</p>
<h2 id="概要">概要</h2>
<p>OffScreenRendererは、VaNillaエンジンにおけるオフスクリーンレンダリングシステムの中核モジュールです。画面に直接表示されないバッファに描画することで、レンダリング・トゥ・テクスチャ、エフェクト処理、UI層分離などの高度な描画技術を提供します。</p>
<h2 id="主要機能">主要機能</h2>
<h3 id="オフスクリーンバッファ管理">オフスクリーンバッファ管理</h3>
<ul>
<li><strong>集中管理</strong>: 現在のレンダリングターゲットの統一管理</li>
<li><strong>スタック機能</strong>: ネストしたオフスクリーンレンダリングの自動管理</li>
<li><strong>透明性</strong>: プラットフォーム固有の詳細を隠蔽した統一API</li>
</ul>
<h3 id="expressercomponent統合">ExpresserComponent統合</h3>
<ul>
<li><strong>OffScreenSource</strong>: オブジェクトにオフスクリーン機能を付与</li>
<li><strong>早期実行</strong>: レンダリング順序制御による適切な実行タイミング</li>
<li><strong>組み合わせ可能</strong>: 他のコンポーネントとの柔軟な組み合わせ</li>
</ul>
<h3 id="高度な描画制御">高度な描画制御</h3>
<ul>
<li><strong>シェーダー統合</strong>: VaNillaシェーダーシステムとの完全連携</li>
<li><strong>変形対応</strong>: 回転、拡縮、カラー変調などの包括的サポート</li>
<li><strong>パフォーマンス最適化</strong>: 効率的なレンダーターゲット切り替え</li>
</ul>
<h2 id="アーキテクチャ">アーキテクチャ</h2>
<h3 id="中核クラス">中核クラス</h3>
<h4 id="offscreenmanager">OffScreenManager</h4>
<p>オフスクリーンレンダリングの集中管理クラスです。</p>
<pre><code class="lang-csharp">public static class OffScreenManager
{
    // 基本レンダーターゲット操作
    public static void SetCurrentOffScreen(OffScreenResource offscreen);
    public static void ClearOffScreen();
    
    // スタック型レンダーターゲット管理
    public static void PushOffScreen(OffScreenResource offscreen);
    public static void PopOffScreen();
}
</code></pre>
<p><strong>主要機能:</strong></p>
<ul>
<li><code>SetCurrentOffScreen()</code>: アクティブなオフスクリーンバッファの設定</li>
<li><code>ClearOffScreen()</code>: 現在のオフスクリーンバッファのクリア</li>
<li><code>PushOffScreen()</code>/<code>PopOffScreen()</code>: スタック型レンダーターゲット管理</li>
</ul>
<h4 id="offscreensource">OffScreenSource</h4>
<p>オブジェクトにオフスクリーン機能を付与するExpresserComponentです。</p>
<pre><code class="lang-csharp">[ExpresserComponentExecutionOrder(ExpresserComponentExecutionOrder.EARLY)]
public class OffScreenSource : IExpresserComponent
{
    public OffScreenResource OffScreenResource { get; set; }
    public Point2 GetRenderTextureResolution();
}
</code></pre>
<p><strong>特徴:</strong></p>
<ul>
<li>早期実行順序による確実なレンダーターゲット設定</li>
<li>オフスクリーンリソースの直接管理</li>
<li>解像度情報の取得機能</li>
</ul>
<h4 id="offscreenobject">OffScreenObject</h4>
<p>オフスクリーンレンダリング用に事前設定されたオブジェクトクラスです。</p>
<pre><code class="lang-csharp">[DefaultExpresserComponent(typeof(OffScreenSource))]
public class OffScreenObject : Object
{
    // OffScreenSourceが自動的に追加される
}
</code></pre>
<h4 id="utils">Utils</h4>
<p>オフスクリーンバッファの描画操作を提供するユーティリティクラスです。</p>
<pre><code class="lang-csharp">public static class Utils
{
    // 基本描画
    public static void Draw(OffScreenResource offscreen, Point2 position);
    
    // 高度な描画
    public static void Draw(OffScreenResource offscreen, Point2 position, 
                           DrawOrigin origin, float rotationDegree, 
                           Point2 scale, Color4 color, 
                           ShaderManager.ShaderEnum shader);
    
    // スタック管理
    public static void PushOffScreen(OffScreenResource offscreen);
    public static void PopOffScreen();
}
</code></pre>
<h3 id="プラットフォーム実装">プラットフォーム実装</h3>
<h4 id="dxlib実装完全対応">DxLib実装（完全対応）</h4>
<pre><code class="lang-csharp">// DxLib/UtilsNative.cs
public static void SetCurrentOffScreen(OffScreenResource offscreen)
{
    DX.SetDrawScreen(offscreen.Handle);
}

public static void Draw(OffScreenResource offscreen, Point2 position, ...)
{
    VaNilla.Renderer.Utils.DrawTextureWithAllParam(...);
}
</code></pre>
<p><strong>特徴:</strong></p>
<ul>
<li>DxLibの<code>SetDrawScreen()</code>を使用した高速レンダーターゲット切り替え</li>
<li>ネイティブハンドルの直接操作による最適化</li>
<li>DxLibの全機能への完全アクセス</li>
</ul>
<h4 id="unity実装開発中">Unity実装（開発中）</h4>
<pre><code class="lang-csharp">// Unity/UtilsNative.cs - TODO実装
public static void SetCurrentOffScreen(OffScreenResource offscreen)
{
    // Unity RenderTexture への対応予定
}
</code></pre>
<h2 id="基本的な使用方法">基本的な使用方法</h2>
<h3 id="シンプルなオフスクリーン描画">シンプルなオフスクリーン描画</h3>
<pre><code class="lang-csharp">public class BasicOffScreenExample
{
    private OffScreenResource renderBuffer;
    
    public void Initialize()
    {
        // オフスクリーンバッファの作成
        renderBuffer = OffScreenResourceManager.LoadOffScreenResource(
            OffScreenResourceType.GameRenderBuffer);
    }
    
    public void RenderToOffScreen()
    {
        // オフスクリーンバッファを設定
        OffScreenManager.SetCurrentOffScreen(renderBuffer);
        
        // バッファをクリア
        OffScreenManager.ClearOffScreen();
        
        // 通常のオブジェクト描画（オフスクリーンバッファに描画される）
        gameScene.RenderAllObjects();
        
        // メインスクリーンに戻す
        OffScreenManager.SetCurrentOffScreen(null);
        
        // オフスクリーンバッファの内容を画面に描画
        Utils.Draw(renderBuffer, new Point2(0, 0));
    }
}
</code></pre>
<h3 id="expressercomponentを使用した方法">ExpresserComponentを使用した方法</h3>
<pre><code class="lang-csharp">public class OffScreenEffectObject : Object
{
    public override void SetUp()
    {
        // OffScreenSourceコンポーネントの追加
        this.AddComponent(new OffScreenSource 
        { 
            OffScreenResource = OffScreenResourceManager.LoadOffScreenResource(
                OffScreenResourceType.EffectBuffer)
        });
    }
    
    public override void Execute()
    {
        var offscreenSource = this.GetComponent&lt;OffScreenSource&gt;();
        
        // このオブジェクトの描画処理は自動的にオフスクリーンバッファに行われる
        // （ExpresserComponentExecutionOrder.EARLYによりレンダーターゲットが事前設定される）
    }
}
</code></pre>
<h3 id="スタック型レンダーターゲット管理">スタック型レンダーターゲット管理</h3>
<pre><code class="lang-csharp">public class NestedOffScreenRenderer
{
    private OffScreenResource primaryBuffer;
    private OffScreenResource secondaryBuffer;
    
    public void ComplexRenderingPipeline()
    {
        // 1. プライマリバッファに基本シーンを描画
        OffScreenManager.PushOffScreen(primaryBuffer);
        RenderBaseScene();
        
        // 2. セカンダリバッファにエフェクトを描画
        OffScreenManager.PushOffScreen(secondaryBuffer);
        RenderEffects();
        
        // 3. エフェクトをプライマリバッファに合成
        OffScreenManager.PopOffScreen(); // セカンダリバッファから戻る
        Utils.Draw(secondaryBuffer, new Point2(0, 0), 
                  DrawOrigin.Center, 0, new Point2(1, 1), 
                  new Color4(1, 1, 1, 0.5f), 
                  ShaderManager.ShaderEnum.Add); // 加算合成
        
        // 4. 最終結果を画面に描画
        OffScreenManager.PopOffScreen(); // メインスクリーンに戻る
        Utils.Draw(primaryBuffer, new Point2(0, 0));
    }
}
</code></pre>
<h2 id="高度な使用例">高度な使用例</h2>
<h3 id="ポストプロセッシングパイプライン">ポストプロセッシングパイプライン</h3>
<pre><code class="lang-csharp">public class PostProcessingPipeline
{
    private OffScreenResource sceneBuffer;
    private OffScreenResource blurBuffer;
    private OffScreenResource bloomBuffer;
    
    public void RenderWithPostProcessing()
    {
        // 1. 基本シーンをレンダリング
        OffScreenManager.PushOffScreen(sceneBuffer);
        OffScreenManager.ClearOffScreen();
        gameWorld.RenderAllObjects();
        OffScreenManager.PopOffScreen();
        
        // 2. ブラー効果の適用
        ApplyBlurEffect(sceneBuffer, blurBuffer);
        
        // 3. ブルーム効果の生成
        GenerateBloomEffect(blurBuffer, bloomBuffer);
        
        // 4. 最終合成
        ComposeEffects();
    }
    
    private void ApplyBlurEffect(OffScreenResource source, OffScreenResource target)
    {
        OffScreenManager.PushOffScreen(target);
        OffScreenManager.ClearOffScreen();
        
        // ブラーシェーダーを使用して描画
        Utils.Draw(source, new Point2(0, 0), 
                  DrawOrigin.LeftTop, 0, new Point2(1, 1), 
                  Color4.White, ShaderManager.ShaderEnum.Blur);
        
        OffScreenManager.PopOffScreen();
    }
    
    private void GenerateBloomEffect(OffScreenResource source, OffScreenResource target)
    {
        OffScreenManager.PushOffScreen(target);
        OffScreenManager.ClearOffScreen();
        
        // 高輝度抽出とブルーム効果
        Utils.Draw(source, new Point2(0, 0), 
                  DrawOrigin.LeftTop, 0, new Point2(1, 1), 
                  Color4.White, ShaderManager.ShaderEnum.BloomExtract);
        
        OffScreenManager.PopOffScreen();
    }
    
    private void ComposeEffects()
    {
        // メインスクリーンに最終合成
        Utils.Draw(sceneBuffer, new Point2(0, 0)); // 基本シーン
        
        Utils.Draw(bloomBuffer, new Point2(0, 0),
                  DrawOrigin.LeftTop, 0, new Point2(1, 1),
                  new Color4(1, 1, 1, 0.3f), 
                  ShaderManager.ShaderEnum.Add); // ブルーム効果を加算
    }
}
</code></pre>
<h3 id="ui層管理システム">UI層管理システム</h3>
<pre><code class="lang-csharp">public class LayeredUISystem
{
    private Dictionary&lt;UILayer, OffScreenResource&gt; uiLayers;
    
    public enum UILayer
    {
        Background,
        Game,
        HUD,
        Menu,
        Dialog
    }
    
    public void InitializeLayers()
    {
        uiLayers = new Dictionary&lt;UILayer, OffScreenResource&gt;
        {
            { UILayer.Background, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.BackgroundLayer) },
            { UILayer.Game, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.GameLayer) },
            { UILayer.HUD, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.HUDLayer) },
            { UILayer.Menu, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.MenuLayer) },
            { UILayer.Dialog, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.DialogLayer) }
        };
    }
    
    public void RenderLayer(UILayer layer, Action renderAction)
    {
        OffScreenManager.PushOffScreen(uiLayers[layer]);
        OffScreenManager.ClearOffScreen();
        
        renderAction(); // 指定された描画処理を実行
        
        OffScreenManager.PopOffScreen();
    }
    
    public void ComposeFinalFrame()
    {
        // 全レイヤーを順序通りに合成
        foreach (var layer in Enum.GetValues&lt;UILayer&gt;())
        {
            if (IsLayerVisible(layer))
            {
                float alpha = GetLayerAlpha(layer);
                Utils.Draw(uiLayers[layer], new Point2(0, 0),
                          DrawOrigin.LeftTop, 0, new Point2(1, 1),
                          new Color4(1, 1, 1, alpha),
                          GetLayerBlendMode(layer));
            }
        }
    }
}
</code></pre>
<h3 id="ミラーポータル効果">ミラー・ポータル効果</h3>
<pre><code class="lang-csharp">public class MirrorPortalEffect
{
    private OffScreenResource mirrorBuffer;
    private Camera mainCamera;
    private Camera mirrorCamera;
    
    public void RenderMirrorEffect(Point2 mirrorPosition, float mirrorAngle)
    {
        // 1. ミラーカメラの設定（反転視点）
        SetupMirrorCamera(mirrorPosition, mirrorAngle);
        
        // 2. ミラービューをオフスクリーンバッファに描画
        OffScreenManager.PushOffScreen(mirrorBuffer);
        OffScreenManager.ClearOffScreen();
        
        CameraManager.SetActiveCamera(mirrorCamera);
        gameWorld.RenderAllObjects();
        CameraManager.SetActiveCamera(mainCamera);
        
        OffScreenManager.PopOffScreen();
        
        // 3. ミラーサーフェスにテクスチャを適用
        RenderMirrorSurface(mirrorPosition, mirrorAngle);
    }
    
    private void RenderMirrorSurface(Point2 position, float angle)
    {
        // ミラーサーフェスにオフスクリーンバッファの内容を描画
        Utils.Draw(mirrorBuffer, position,
                  DrawOrigin.Center, angle, new Point2(1, -1), // Y軸反転
                  Color4.White, ShaderManager.ShaderEnum.Mirror);
    }
}
</code></pre>
<h2 id="パフォーマンス最適化">パフォーマンス最適化</h2>
<h3 id="効率的なバッファ管理">効率的なバッファ管理</h3>
<pre><code class="lang-csharp">public class OptimizedOffScreenManager
{
    private static Stack&lt;OffScreenResource&gt; renderTargetStack = new Stack&lt;OffScreenResource&gt;();
    private static OffScreenResource currentTarget = null;
    
    public static void PushOffScreenOptimized(OffScreenResource offscreen)
    {
        // 同じターゲットへの無駄な切り替えを回避
        if (currentTarget != offscreen)
        {
            if (currentTarget != null)
            {
                renderTargetStack.Push(currentTarget);
            }
            
            OffScreenManager.SetCurrentOffScreen(offscreen);
            currentTarget = offscreen;
        }
    }
    
    public static void PopOffScreenOptimized()
    {
        if (renderTargetStack.Count &gt; 0)
        {
            var previousTarget = renderTargetStack.Pop();
            OffScreenManager.SetCurrentOffScreen(previousTarget);
            currentTarget = previousTarget;
        }
        else
        {
            OffScreenManager.SetCurrentOffScreen(null);
            currentTarget = null;
        }
    }
}
</code></pre>
<h3 id="バッチ処理最適化">バッチ処理最適化</h3>
<pre><code class="lang-csharp">public class BatchOffScreenRenderer
{
    private List&lt;(OffScreenResource buffer, Action renderAction)&gt; renderBatches;
    
    public void AddRenderBatch(OffScreenResource buffer, Action renderAction)
    {
        renderBatches.Add((buffer, renderAction));
    }
    
    public void ExecuteBatches()
    {
        // バッファ別にバッチをグループ化
        var groupedBatches = renderBatches.GroupBy(batch =&gt; batch.buffer);
        
        foreach (var group in groupedBatches)
        {
            // 同じバッファに対する描画をまとめて実行
            OffScreenManager.PushOffScreen(group.Key);
            OffScreenManager.ClearOffScreen();
            
            foreach (var (buffer, renderAction) in group)
            {
                renderAction();
            }
            
            OffScreenManager.PopOffScreen();
        }
        
        renderBatches.Clear();
    }
}
</code></pre>
<h2 id="offscreenresourcemanagerとの連携">OffScreenResourceManagerとの連携</h2>
<pre><code class="lang-csharp">public class OffScreenResourceIntegration
{
    public void DemonstrateResourceManagement()
    {
        // 1. リソースの読み込み（OffScreenResourceManager経由）
        var gameBuffer = OffScreenResourceManager.LoadOffScreenResource(
            OffScreenResourceType.GameBuffer);
        
        var effectBuffer = OffScreenResourceManager.LoadOffScreenResource(
            OffScreenResourceType.EffectBuffer);
        
        // 2. OffScreenRendererでの使用
        OffScreenManager.SetCurrentOffScreen(gameBuffer);
        // 描画処理...
        
        // 3. リソースの解放（OffScreenResourceManager経由）
        OffScreenResourceManager.UnloadOffScreenResource(
            OffScreenResourceType.GameBuffer);
    }
}
</code></pre>
<h2 id="デバッグとトラブルシューティング">デバッグとトラブルシューティング</h2>
<h3 id="デバッグ情報の表示">デバッグ情報の表示</h3>
<pre><code class="lang-csharp">public class OffScreenDebugger
{
    public static void LogRenderTargetState()
    {
        var currentTarget = GetCurrentOffScreenTarget();
        VaNilla.Debug.Logger.LogInfo($&quot;Current render target: {currentTarget?.ToString() ?? &quot;Main Screen&quot;}&quot;);
        
        var stackDepth = GetRenderTargetStackDepth();
        VaNilla.Debug.Logger.LogInfo($&quot;Render target stack depth: {stackDepth}&quot;);
    }
    
    public static void ValidateOffScreenResource(OffScreenResource resource)
    {
        if (resource == null)
        {
            VaNilla.Debug.Logger.LogError(&quot;OffScreenResource is null&quot;);
            return;
        }
        
        var resolution = resource.GetResolution();
        VaNilla.Debug.Logger.LogInfo($&quot;OffScreen resolution: {resolution.X}x{resolution.Y}&quot;);
        
        if (resolution.X &lt;= 0 || resolution.Y &lt;= 0)
        {
            VaNilla.Debug.Logger.LogWarning(&quot;Invalid OffScreen resolution detected&quot;);
        }
    }
}
</code></pre>
<h3 id="よくある問題と解決法">よくある問題と解決法</h3>
<pre><code class="lang-csharp">public class OffScreenTroubleshooting
{
    // 1. レンダーターゲットの復元忘れ
    public void SafeOffScreenRendering(OffScreenResource target, Action renderAction)
    {
        try
        {
            OffScreenManager.PushOffScreen(target);
            renderAction();
        }
        finally
        {
            OffScreenManager.PopOffScreen(); // 確実に復元
        }
    }
    
    // 2. スタックの不整合チェック
    public void ValidateRenderTargetStack()
    {
        int expectedStackDepth = CalculateExpectedStackDepth();
        int actualStackDepth = GetActualStackDepth();
        
        if (expectedStackDepth != actualStackDepth)
        {
            VaNilla.Debug.Logger.LogError($&quot;Render target stack mismatch! Expected: {expectedStackDepth}, Actual: {actualStackDepth}&quot;);
            // スタックのリセット処理
            ResetRenderTargetStack();
        }
    }
    
    // 3. メモリリークの監視
    public void MonitorOffScreenMemoryUsage()
    {
        var totalMemory = CalculateOffScreenMemoryUsage();
        var threshold = GetMemoryThreshold();
        
        if (totalMemory &gt; threshold)
        {
            VaNilla.Debug.Logger.LogWarning($&quot;OffScreen memory usage high: {totalMemory}MB&quot;);
            TriggerGarbageCollection();
        }
    }
}
</code></pre>
<h2 id="プラットフォーム対応状況">プラットフォーム対応状況</h2>
<table>
<thead>
<tr>
<th>機能</th>
<th>DxLib</th>
<th>Unity</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本オフスクリーン描画</td>
<td>✅</td>
<td>🚧</td>
</tr>
<tr>
<td>レンダーターゲット切り替え</td>
<td>✅</td>
<td>🚧</td>
</tr>
<tr>
<td>スタック管理</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>シェーダー統合</td>
<td>✅</td>
<td>🚧</td>
</tr>
<tr>
<td>高度な描画パラメータ</td>
<td>✅</td>
<td>🚧</td>
</tr>
</tbody>
</table>
<p>✅ 実装済み / 🚧 開発中</p>
<h2 id="依存関係">依存関係</h2>
<ul>
<li><strong>OffScreenResourceManager</strong>: オフスクリーンリソースの作成・管理</li>
<li><strong>Renderer</strong>: 基本描画機能</li>
<li><strong>ShaderManager</strong>: シェーダーシステム</li>
<li><strong>DebugLogger</strong>: ログ出力</li>
<li><strong>ExpresserComponent</strong>: コンポーネントシステム</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>OffScreenRendererは、VaNillaエンジンにおける高度な描画技術の基盤となるモジュールです。テクスチャレンダリング、ポストプロセッシング、UI層管理などの現代的なグラフィックス技術を実現し、ゲームの視覚品質向上に大きく貢献します。適切な使用により、プロフェッショナルレベルのグラフィックス効果を効率的に実装できます。</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/EndlessShirafu/VaNilla/blob/develop/Documents/docfx/modules/OffScreenRenderer/README.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>

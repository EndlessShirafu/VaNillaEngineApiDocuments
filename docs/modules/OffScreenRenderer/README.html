<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>OffScreenRenderer </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="OffScreenRenderer ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/EndlessShirafu/VaNilla/blob/feature/apply-net10-and-csharp14/Documents/docfx/modules/OffScreenRenderer/README.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="offscreenrenderer">OffScreenRenderer</h1>

<p>ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã®æç”»ã€ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ã€ãƒãƒ«ãƒãƒ‘ã‚¹ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãªã©ã®é«˜åº¦ãªæç”»æŠ€è¡“ã‚’å®Ÿç¾ã—ã¾ã™ã€‚</p>
<h2 id="æ¦‚è¦">æ¦‚è¦</h2>
<p>OffScreenRendererã¯ã€VaNillaã‚¨ãƒ³ã‚¸ãƒ³ã«ãŠã‘ã‚‹ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ä¸­æ ¸ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚ç”»é¢ã«ç›´æ¥è¡¨ç¤ºã•ã‚Œãªã„ãƒãƒƒãƒ•ã‚¡ã«æç”»ã™ã‚‹ã“ã¨ã§ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ»ãƒˆã‚¥ãƒ»ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‡¦ç†ã€UIå±¤åˆ†é›¢ãªã©ã®é«˜åº¦ãªæç”»æŠ€è¡“ã‚’æä¾›ã—ã¾ã™ã€‚</p>
<h2 id="ä¸»è¦æ©Ÿèƒ½">ä¸»è¦æ©Ÿèƒ½</h2>
<h3 id="ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ç®¡ç†">ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ç®¡ç†</h3>
<ul>
<li><strong>é›†ä¸­ç®¡ç†</strong>: ç¾åœ¨ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®çµ±ä¸€ç®¡ç†</li>
<li><strong>ã‚¹ã‚¿ãƒƒã‚¯æ©Ÿèƒ½</strong>: ãƒã‚¹ãƒˆã—ãŸã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®è‡ªå‹•ç®¡ç†</li>
<li><strong>é€æ˜æ€§</strong>: ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å›ºæœ‰ã®è©³ç´°ã‚’éš è”½ã—ãŸçµ±ä¸€API</li>
</ul>
<h3 id="expressercomponentçµ±åˆ">ExpresserComponentçµ±åˆ</h3>
<ul>
<li><strong>OffScreenSource</strong>: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³æ©Ÿèƒ½ã‚’ä»˜ä¸</li>
<li><strong>æ—©æœŸå®Ÿè¡Œ</strong>: ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é †åºåˆ¶å¾¡ã«ã‚ˆã‚‹é©åˆ‡ãªå®Ÿè¡Œã‚¿ã‚¤ãƒŸãƒ³ã‚°</li>
<li><strong>çµ„ã¿åˆã‚ã›å¯èƒ½</strong>: ä»–ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¨ã®æŸ”è»Ÿãªçµ„ã¿åˆã‚ã›</li>
</ul>
<h3 id="é«˜åº¦ãªæç”»åˆ¶å¾¡">é«˜åº¦ãªæç”»åˆ¶å¾¡</h3>
<ul>
<li><strong>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼çµ±åˆ</strong>: VaNillaã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã¨ã®å®Œå…¨é€£æº</li>
<li><strong>å¤‰å½¢å¯¾å¿œ</strong>: å›è»¢ã€æ‹¡ç¸®ã€ã‚«ãƒ©ãƒ¼å¤‰èª¿ãªã©ã®åŒ…æ‹¬çš„ã‚µãƒãƒ¼ãƒˆ</li>
<li><strong>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–</strong>: åŠ¹ç‡çš„ãªãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåˆ‡ã‚Šæ›¿ãˆ</li>
</ul>
<h2 id="ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£">ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£</h2>
<h3 id="ä¸­æ ¸ã‚¯ãƒ©ã‚¹">ä¸­æ ¸ã‚¯ãƒ©ã‚¹</h3>
<h4 id="offscreenmanager">OffScreenManager</h4>
<p>ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®é›†ä¸­ç®¡ç†ã‚¯ãƒ©ã‚¹ã§ã™ã€‚</p>
<pre><code class="lang-csharp">public static class OffScreenManager
{
    // åŸºæœ¬ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ“ä½œ
    public static void SetCurrentOffScreen(OffScreenResource offscreen);
    public static void ClearOffScreen();
    
    // ã‚¹ã‚¿ãƒƒã‚¯å‹ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç®¡ç†
    public static void PushOffScreen(OffScreenResource offscreen);
    public static void PopOffScreen();
}
</code></pre>
<p><strong>ä¸»è¦æ©Ÿèƒ½:</strong></p>
<ul>
<li><code>SetCurrentOffScreen()</code>: ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã®è¨­å®š</li>
<li><code>ClearOffScreen()</code>: ç¾åœ¨ã®ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã®ã‚¯ãƒªã‚¢</li>
<li><code>PushOffScreen()</code>/<code>PopOffScreen()</code>: ã‚¹ã‚¿ãƒƒã‚¯å‹ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç®¡ç†</li>
</ul>
<h4 id="offscreensource">OffScreenSource</h4>
<p>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³æ©Ÿèƒ½ã‚’ä»˜ä¸ã™ã‚‹ExpresserComponentã§ã™ã€‚</p>
<pre><code class="lang-csharp">[ExpresserComponentExecutionOrder(ExpresserComponentExecutionOrder.EARLY)]
public class OffScreenSource : IExpresserComponent
{
    public OffScreenResource OffScreenResource { get; set; }
    public Point2 GetRenderTextureResolution();
}
</code></pre>
<p><strong>ç‰¹å¾´:</strong></p>
<ul>
<li>æ—©æœŸå®Ÿè¡Œé †åºã«ã‚ˆã‚‹ç¢ºå®Ÿãªãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š</li>
<li>ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒªã‚½ãƒ¼ã‚¹ã®ç›´æ¥ç®¡ç†</li>
<li>è§£åƒåº¦æƒ…å ±ã®å–å¾—æ©Ÿèƒ½</li>
</ul>
<h4 id="offscreenobject">OffScreenObject</h4>
<p>ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ç”¨ã«äº‹å‰è¨­å®šã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ã§ã™ã€‚</p>
<pre><code class="lang-csharp">[DefaultExpresserComponent(typeof(OffScreenSource))]
public class OffScreenObject : Object
{
    // OffScreenSourceãŒè‡ªå‹•çš„ã«è¿½åŠ ã•ã‚Œã‚‹
}
</code></pre>
<h4 id="utils">Utils</h4>
<p>ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã®æç”»æ“ä½œã‚’æä¾›ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹ã§ã™ã€‚</p>
<pre><code class="lang-csharp">public static class Utils
{
    // åŸºæœ¬æç”»
    public static void Draw(OffScreenResource offscreen, Point2 position);
    
    // é«˜åº¦ãªæç”»
    public static void Draw(OffScreenResource offscreen, Point2 position, 
                           DrawOrigin origin, float rotationDegree, 
                           Point2 scale, Color4 color, 
                           ShaderManager.ShaderEnum shader);
    
    // ã‚¹ã‚¿ãƒƒã‚¯ç®¡ç†
    public static void PushOffScreen(OffScreenResource offscreen);
    public static void PopOffScreen();
}
</code></pre>
<h3 id="ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å®Ÿè£…">ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å®Ÿè£…</h3>
<h4 id="dxlibå®Ÿè£…å®Œå…¨å¯¾å¿œ">DxLibå®Ÿè£…ï¼ˆå®Œå…¨å¯¾å¿œï¼‰</h4>
<pre><code class="lang-csharp">// DxLib/UtilsNative.cs
public static void SetCurrentOffScreen(OffScreenResource offscreen)
{
    DX.SetDrawScreen(offscreen.Handle);
}

public static void Draw(OffScreenResource offscreen, Point2 position, ...)
{
    VaNilla.Renderer.Utils.DrawTextureWithAllParam(...);
}
</code></pre>
<p><strong>ç‰¹å¾´:</strong></p>
<ul>
<li>DxLibã®<code>SetDrawScreen()</code>ã‚’ä½¿ç”¨ã—ãŸé«˜é€Ÿãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåˆ‡ã‚Šæ›¿ãˆ</li>
<li>ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒãƒ³ãƒ‰ãƒ«ã®ç›´æ¥æ“ä½œã«ã‚ˆã‚‹æœ€é©åŒ–</li>
<li>DxLibã®å…¨æ©Ÿèƒ½ã¸ã®å®Œå…¨ã‚¢ã‚¯ã‚»ã‚¹</li>
</ul>
<h4 id="unityå®Ÿè£…é–‹ç™ºä¸­">Unityå®Ÿè£…ï¼ˆé–‹ç™ºä¸­ï¼‰</h4>
<pre><code class="lang-csharp">// Unity/UtilsNative.cs - TODOå®Ÿè£…
public static void SetCurrentOffScreen(OffScreenResource offscreen)
{
    // Unity RenderTexture ã¸ã®å¯¾å¿œäºˆå®š
}
</code></pre>
<h2 id="åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•">åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•</h2>
<h3 id="ã‚·ãƒ³ãƒ—ãƒ«ãªã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³æç”»">ã‚·ãƒ³ãƒ—ãƒ«ãªã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³æç”»</h3>
<pre><code class="lang-csharp">public class BasicOffScreenExample
{
    private OffScreenResource renderBuffer;
    
    public void Initialize()
    {
        // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã®ä½œæˆ
        renderBuffer = OffScreenResourceManager.LoadOffScreenResource(
            OffScreenResourceType.GameRenderBuffer);
    }
    
    public void RenderToOffScreen()
    {
        // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®š
        OffScreenManager.SetCurrentOffScreen(renderBuffer);
        
        // ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¯ãƒªã‚¢
        OffScreenManager.ClearOffScreen();
        
        // é€šå¸¸ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæç”»ï¼ˆã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã«æç”»ã•ã‚Œã‚‹ï¼‰
        gameScene.RenderAllObjects();
        
        // ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã«æˆ»ã™
        OffScreenManager.SetCurrentOffScreen(null);
        
        // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã®å†…å®¹ã‚’ç”»é¢ã«æç”»
        Utils.Draw(renderBuffer, new Point2(0, 0));
    }
}
</code></pre>
<h3 id="expressercomponentã‚’ä½¿ç”¨ã—ãŸæ–¹æ³•">ExpresserComponentã‚’ä½¿ç”¨ã—ãŸæ–¹æ³•</h3>
<pre><code class="lang-csharp">public class OffScreenEffectObject : Object
{
    public override void SetUp()
    {
        // OffScreenSourceã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®è¿½åŠ 
        this.AddComponent(new OffScreenSource 
        { 
            OffScreenResource = OffScreenResourceManager.LoadOffScreenResource(
                OffScreenResourceType.EffectBuffer)
        });
    }
    
    public override void Execute()
    {
        var offscreenSource = this.GetComponent&lt;OffScreenSource&gt;();
        
        // ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»å‡¦ç†ã¯è‡ªå‹•çš„ã«ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã«è¡Œã‚ã‚Œã‚‹
        // ï¼ˆExpresserComponentExecutionOrder.EARLYã«ã‚ˆã‚Šãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒäº‹å‰è¨­å®šã•ã‚Œã‚‹ï¼‰
    }
}
</code></pre>
<h3 id="ã‚¹ã‚¿ãƒƒã‚¯å‹ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç®¡ç†">ã‚¹ã‚¿ãƒƒã‚¯å‹ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç®¡ç†</h3>
<pre><code class="lang-csharp">public class NestedOffScreenRenderer
{
    private OffScreenResource primaryBuffer;
    private OffScreenResource secondaryBuffer;
    
    public void ComplexRenderingPipeline()
    {
        // 1. ãƒ—ãƒ©ã‚¤ãƒãƒªãƒãƒƒãƒ•ã‚¡ã«åŸºæœ¬ã‚·ãƒ¼ãƒ³ã‚’æç”»
        OffScreenManager.PushOffScreen(primaryBuffer);
        RenderBaseScene();
        
        // 2. ã‚»ã‚«ãƒ³ãƒ€ãƒªãƒãƒƒãƒ•ã‚¡ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’æç”»
        OffScreenManager.PushOffScreen(secondaryBuffer);
        RenderEffects();
        
        // 3. ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ãƒ—ãƒ©ã‚¤ãƒãƒªãƒãƒƒãƒ•ã‚¡ã«åˆæˆ
        OffScreenManager.PopOffScreen(); // ã‚»ã‚«ãƒ³ãƒ€ãƒªãƒãƒƒãƒ•ã‚¡ã‹ã‚‰æˆ»ã‚‹
        Utils.Draw(secondaryBuffer, new Point2(0, 0), 
                  DrawOrigin.Center, 0, new Point2(1, 1), 
                  new Color4(1, 1, 1, 0.5f), 
                  ShaderManager.ShaderEnum.Add); // åŠ ç®—åˆæˆ
        
        // 4. æœ€çµ‚çµæœã‚’ç”»é¢ã«æç”»
        OffScreenManager.PopOffScreen(); // ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã«æˆ»ã‚‹
        Utils.Draw(primaryBuffer, new Point2(0, 0));
    }
}
</code></pre>
<h2 id="é«˜åº¦ãªä½¿ç”¨ä¾‹">é«˜åº¦ãªä½¿ç”¨ä¾‹</h2>
<h3 id="ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³">ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</h3>
<pre><code class="lang-csharp">public class PostProcessingPipeline
{
    private OffScreenResource sceneBuffer;
    private OffScreenResource blurBuffer;
    private OffScreenResource bloomBuffer;
    
    public void RenderWithPostProcessing()
    {
        // 1. åŸºæœ¬ã‚·ãƒ¼ãƒ³ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
        OffScreenManager.PushOffScreen(sceneBuffer);
        OffScreenManager.ClearOffScreen();
        gameWorld.RenderAllObjects();
        OffScreenManager.PopOffScreen();
        
        // 2. ãƒ–ãƒ©ãƒ¼åŠ¹æœã®é©ç”¨
        ApplyBlurEffect(sceneBuffer, blurBuffer);
        
        // 3. ãƒ–ãƒ«ãƒ¼ãƒ åŠ¹æœã®ç”Ÿæˆ
        GenerateBloomEffect(blurBuffer, bloomBuffer);
        
        // 4. æœ€çµ‚åˆæˆ
        ComposeEffects();
    }
    
    private void ApplyBlurEffect(OffScreenResource source, OffScreenResource target)
    {
        OffScreenManager.PushOffScreen(target);
        OffScreenManager.ClearOffScreen();
        
        // ãƒ–ãƒ©ãƒ¼ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’ä½¿ç”¨ã—ã¦æç”»
        Utils.Draw(source, new Point2(0, 0), 
                  DrawOrigin.LeftTop, 0, new Point2(1, 1), 
                  Color4.White, ShaderManager.ShaderEnum.Blur);
        
        OffScreenManager.PopOffScreen();
    }
    
    private void GenerateBloomEffect(OffScreenResource source, OffScreenResource target)
    {
        OffScreenManager.PushOffScreen(target);
        OffScreenManager.ClearOffScreen();
        
        // é«˜è¼åº¦æŠ½å‡ºã¨ãƒ–ãƒ«ãƒ¼ãƒ åŠ¹æœ
        Utils.Draw(source, new Point2(0, 0), 
                  DrawOrigin.LeftTop, 0, new Point2(1, 1), 
                  Color4.White, ShaderManager.ShaderEnum.BloomExtract);
        
        OffScreenManager.PopOffScreen();
    }
    
    private void ComposeEffects()
    {
        // ãƒ¡ã‚¤ãƒ³ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã«æœ€çµ‚åˆæˆ
        Utils.Draw(sceneBuffer, new Point2(0, 0)); // åŸºæœ¬ã‚·ãƒ¼ãƒ³
        
        Utils.Draw(bloomBuffer, new Point2(0, 0),
                  DrawOrigin.LeftTop, 0, new Point2(1, 1),
                  new Color4(1, 1, 1, 0.3f), 
                  ShaderManager.ShaderEnum.Add); // ãƒ–ãƒ«ãƒ¼ãƒ åŠ¹æœã‚’åŠ ç®—
    }
}
</code></pre>
<h3 id="uiå±¤ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ">UIå±¤ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </h3>
<pre><code class="lang-csharp">public class LayeredUISystem
{
    private Dictionary&lt;UILayer, OffScreenResource&gt; uiLayers;
    
    public enum UILayer
    {
        Background,
        Game,
        HUD,
        Menu,
        Dialog
    }
    
    public void InitializeLayers()
    {
        uiLayers = new Dictionary&lt;UILayer, OffScreenResource&gt;
        {
            { UILayer.Background, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.BackgroundLayer) },
            { UILayer.Game, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.GameLayer) },
            { UILayer.HUD, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.HUDLayer) },
            { UILayer.Menu, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.MenuLayer) },
            { UILayer.Dialog, OffScreenResourceManager.LoadOffScreenResource(OffScreenResourceType.DialogLayer) }
        };
    }
    
    public void RenderLayer(UILayer layer, Action renderAction)
    {
        OffScreenManager.PushOffScreen(uiLayers[layer]);
        OffScreenManager.ClearOffScreen();
        
        renderAction(); // æŒ‡å®šã•ã‚ŒãŸæç”»å‡¦ç†ã‚’å®Ÿè¡Œ
        
        OffScreenManager.PopOffScreen();
    }
    
    public void ComposeFinalFrame()
    {
        // å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é †åºé€šã‚Šã«åˆæˆ
        foreach (var layer in Enum.GetValues&lt;UILayer&gt;())
        {
            if (IsLayerVisible(layer))
            {
                float alpha = GetLayerAlpha(layer);
                Utils.Draw(uiLayers[layer], new Point2(0, 0),
                          DrawOrigin.LeftTop, 0, new Point2(1, 1),
                          new Color4(1, 1, 1, alpha),
                          GetLayerBlendMode(layer));
            }
        }
    }
}
</code></pre>
<h3 id="ãƒŸãƒ©ãƒ¼ãƒãƒ¼ã‚¿ãƒ«åŠ¹æœ">ãƒŸãƒ©ãƒ¼ãƒ»ãƒãƒ¼ã‚¿ãƒ«åŠ¹æœ</h3>
<pre><code class="lang-csharp">public class MirrorPortalEffect
{
    private OffScreenResource mirrorBuffer;
    private Camera mainCamera;
    private Camera mirrorCamera;
    
    public void RenderMirrorEffect(Point2 mirrorPosition, float mirrorAngle)
    {
        // 1. ãƒŸãƒ©ãƒ¼ã‚«ãƒ¡ãƒ©ã®è¨­å®šï¼ˆåè»¢è¦–ç‚¹ï¼‰
        SetupMirrorCamera(mirrorPosition, mirrorAngle);
        
        // 2. ãƒŸãƒ©ãƒ¼ãƒ“ãƒ¥ãƒ¼ã‚’ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã«æç”»
        OffScreenManager.PushOffScreen(mirrorBuffer);
        OffScreenManager.ClearOffScreen();
        
        CameraManager.SetActiveCamera(mirrorCamera);
        gameWorld.RenderAllObjects();
        CameraManager.SetActiveCamera(mainCamera);
        
        OffScreenManager.PopOffScreen();
        
        // 3. ãƒŸãƒ©ãƒ¼ã‚µãƒ¼ãƒ•ã‚§ã‚¹ã«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’é©ç”¨
        RenderMirrorSurface(mirrorPosition, mirrorAngle);
    }
    
    private void RenderMirrorSurface(Point2 position, float angle)
    {
        // ãƒŸãƒ©ãƒ¼ã‚µãƒ¼ãƒ•ã‚§ã‚¹ã«ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒãƒƒãƒ•ã‚¡ã®å†…å®¹ã‚’æç”»
        Utils.Draw(mirrorBuffer, position,
                  DrawOrigin.Center, angle, new Point2(1, -1), // Yè»¸åè»¢
                  Color4.White, ShaderManager.ShaderEnum.Mirror);
    }
}
</code></pre>
<h2 id="ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–</h2>
<h3 id="åŠ¹ç‡çš„ãªãƒãƒƒãƒ•ã‚¡ç®¡ç†">åŠ¹ç‡çš„ãªãƒãƒƒãƒ•ã‚¡ç®¡ç†</h3>
<pre><code class="lang-csharp">public class OptimizedOffScreenManager
{
    private static Stack&lt;OffScreenResource&gt; renderTargetStack = new Stack&lt;OffScreenResource&gt;();
    private static OffScreenResource currentTarget = null;
    
    public static void PushOffScreenOptimized(OffScreenResource offscreen)
    {
        // åŒã˜ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ã®ç„¡é§„ãªåˆ‡ã‚Šæ›¿ãˆã‚’å›é¿
        if (currentTarget != offscreen)
        {
            if (currentTarget != null)
            {
                renderTargetStack.Push(currentTarget);
            }
            
            OffScreenManager.SetCurrentOffScreen(offscreen);
            currentTarget = offscreen;
        }
    }
    
    public static void PopOffScreenOptimized()
    {
        if (renderTargetStack.Count &gt; 0)
        {
            var previousTarget = renderTargetStack.Pop();
            OffScreenManager.SetCurrentOffScreen(previousTarget);
            currentTarget = previousTarget;
        }
        else
        {
            OffScreenManager.SetCurrentOffScreen(null);
            currentTarget = null;
        }
    }
}
</code></pre>
<h3 id="ãƒãƒƒãƒå‡¦ç†æœ€é©åŒ–">ãƒãƒƒãƒå‡¦ç†æœ€é©åŒ–</h3>
<pre><code class="lang-csharp">public class BatchOffScreenRenderer
{
    private List&lt;(OffScreenResource buffer, Action renderAction)&gt; renderBatches;
    
    public void AddRenderBatch(OffScreenResource buffer, Action renderAction)
    {
        renderBatches.Add((buffer, renderAction));
    }
    
    public void ExecuteBatches()
    {
        // ãƒãƒƒãƒ•ã‚¡åˆ¥ã«ãƒãƒƒãƒã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
        var groupedBatches = renderBatches.GroupBy(batch =&gt; batch.buffer);
        
        foreach (var group in groupedBatches)
        {
            // åŒã˜ãƒãƒƒãƒ•ã‚¡ã«å¯¾ã™ã‚‹æç”»ã‚’ã¾ã¨ã‚ã¦å®Ÿè¡Œ
            OffScreenManager.PushOffScreen(group.Key);
            OffScreenManager.ClearOffScreen();
            
            foreach (var (buffer, renderAction) in group)
            {
                renderAction();
            }
            
            OffScreenManager.PopOffScreen();
        }
        
        renderBatches.Clear();
    }
}
</code></pre>
<h2 id="offscreenresourcemanagerã¨ã®é€£æº">OffScreenResourceManagerã¨ã®é€£æº</h2>
<pre><code class="lang-csharp">public class OffScreenResourceIntegration
{
    public void DemonstrateResourceManagement()
    {
        // 1. ãƒªã‚½ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿ï¼ˆOffScreenResourceManagerçµŒç”±ï¼‰
        var gameBuffer = OffScreenResourceManager.LoadOffScreenResource(
            OffScreenResourceType.GameBuffer);
        
        var effectBuffer = OffScreenResourceManager.LoadOffScreenResource(
            OffScreenResourceType.EffectBuffer);
        
        // 2. OffScreenRendererã§ã®ä½¿ç”¨
        OffScreenManager.SetCurrentOffScreen(gameBuffer);
        // æç”»å‡¦ç†...
        
        // 3. ãƒªã‚½ãƒ¼ã‚¹ã®è§£æ”¾ï¼ˆOffScreenResourceManagerçµŒç”±ï¼‰
        OffScreenResourceManager.UnloadOffScreenResource(
            OffScreenResourceType.GameBuffer);
    }
}
</code></pre>
<h2 id="ãƒ‡ãƒãƒƒã‚°ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°">ãƒ‡ãƒãƒƒã‚°ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°</h2>
<h3 id="ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®è¡¨ç¤º">ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®è¡¨ç¤º</h3>
<pre><code class="lang-csharp">public class OffScreenDebugger
{
    public static void LogRenderTargetState()
    {
        var currentTarget = GetCurrentOffScreenTarget();
        VaNilla.Debug.Logger.LogInfo($&quot;Current render target: {currentTarget?.ToString() ?? &quot;Main Screen&quot;}&quot;);
        
        var stackDepth = GetRenderTargetStackDepth();
        VaNilla.Debug.Logger.LogInfo($&quot;Render target stack depth: {stackDepth}&quot;);
    }
    
    public static void ValidateOffScreenResource(OffScreenResource resource)
    {
        if (resource == null)
        {
            VaNilla.Debug.Logger.LogError(&quot;OffScreenResource is null&quot;);
            return;
        }
        
        var resolution = resource.GetResolution();
        VaNilla.Debug.Logger.LogInfo($&quot;OffScreen resolution: {resolution.X}x{resolution.Y}&quot;);
        
        if (resolution.X &lt;= 0 || resolution.Y &lt;= 0)
        {
            VaNilla.Debug.Logger.LogWarning(&quot;Invalid OffScreen resolution detected&quot;);
        }
    }
}
</code></pre>
<h3 id="ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ³•">ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ³•</h3>
<pre><code class="lang-csharp">public class OffScreenTroubleshooting
{
    // 1. ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å¾©å…ƒå¿˜ã‚Œ
    public void SafeOffScreenRendering(OffScreenResource target, Action renderAction)
    {
        try
        {
            OffScreenManager.PushOffScreen(target);
            renderAction();
        }
        finally
        {
            OffScreenManager.PopOffScreen(); // ç¢ºå®Ÿã«å¾©å…ƒ
        }
    }
    
    // 2. ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸æ•´åˆãƒã‚§ãƒƒã‚¯
    public void ValidateRenderTargetStack()
    {
        int expectedStackDepth = CalculateExpectedStackDepth();
        int actualStackDepth = GetActualStackDepth();
        
        if (expectedStackDepth != actualStackDepth)
        {
            VaNilla.Debug.Logger.LogError($&quot;Render target stack mismatch! Expected: {expectedStackDepth}, Actual: {actualStackDepth}&quot;);
            // ã‚¹ã‚¿ãƒƒã‚¯ã®ãƒªã‚»ãƒƒãƒˆå‡¦ç†
            ResetRenderTargetStack();
        }
    }
    
    // 3. ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®ç›£è¦–
    public void MonitorOffScreenMemoryUsage()
    {
        var totalMemory = CalculateOffScreenMemoryUsage();
        var threshold = GetMemoryThreshold();
        
        if (totalMemory &gt; threshold)
        {
            VaNilla.Debug.Logger.LogWarning($&quot;OffScreen memory usage high: {totalMemory}MB&quot;);
            TriggerGarbageCollection();
        }
    }
}
</code></pre>
<h2 id="ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œçŠ¶æ³">ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œçŠ¶æ³</h2>
<table>
<thead>
<tr>
<th>æ©Ÿèƒ½</th>
<th>DxLib</th>
<th>Unity</th>
</tr>
</thead>
<tbody>
<tr>
<td>åŸºæœ¬ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³æç”»</td>
<td>âœ…</td>
<td>ğŸš§</td>
</tr>
<tr>
<td>ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåˆ‡ã‚Šæ›¿ãˆ</td>
<td>âœ…</td>
<td>ğŸš§</td>
</tr>
<tr>
<td>ã‚¹ã‚¿ãƒƒã‚¯ç®¡ç†</td>
<td>âœ…</td>
<td>âœ…</td>
</tr>
<tr>
<td>ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼çµ±åˆ</td>
<td>âœ…</td>
<td>ğŸš§</td>
</tr>
<tr>
<td>é«˜åº¦ãªæç”»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</td>
<td>âœ…</td>
<td>ğŸš§</td>
</tr>
</tbody>
</table>
<p>âœ… å®Ÿè£…æ¸ˆã¿ / ğŸš§ é–‹ç™ºä¸­</p>
<h2 id="ä¾å­˜é–¢ä¿‚">ä¾å­˜é–¢ä¿‚</h2>
<ul>
<li><strong>OffScreenResourceManager</strong>: ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆãƒ»ç®¡ç†</li>
<li><strong>Renderer</strong>: åŸºæœ¬æç”»æ©Ÿèƒ½</li>
<li><strong>ShaderManager</strong>: ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚·ã‚¹ãƒ†ãƒ </li>
<li><strong>DebugLogger</strong>: ãƒ­ã‚°å‡ºåŠ›</li>
<li><strong>ExpresserComponent</strong>: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ </li>
</ul>
<h2 id="ã¾ã¨ã‚">ã¾ã¨ã‚</h2>
<p>OffScreenRendererã¯ã€VaNillaã‚¨ãƒ³ã‚¸ãƒ³ã«ãŠã‘ã‚‹é«˜åº¦ãªæç”»æŠ€è¡“ã®åŸºç›¤ã¨ãªã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã€ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ãƒƒã‚·ãƒ³ã‚°ã€UIå±¤ç®¡ç†ãªã©ã®ç¾ä»£çš„ãªã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹æŠ€è¡“ã‚’å®Ÿç¾ã—ã€ã‚²ãƒ¼ãƒ ã®è¦–è¦šå“è³ªå‘ä¸Šã«å¤§ããè²¢çŒ®ã—ã¾ã™ã€‚é©åˆ‡ãªä½¿ç”¨ã«ã‚ˆã‚Šã€ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãƒ¬ãƒ™ãƒ«ã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹åŠ¹æœã‚’åŠ¹ç‡çš„ã«å®Ÿè£…ã§ãã¾ã™ã€‚</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/EndlessShirafu/VaNilla/blob/feature/apply-net10-and-csharp14/Documents/docfx/modules/OffScreenRenderer/README.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>

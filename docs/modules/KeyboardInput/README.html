<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>KeyboardInput </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="KeyboardInput ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/EndlessShirafu/VaNilla/blob/develop/Documents/docfx/modules/KeyboardInput/README.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="keyboardinput">KeyboardInput</h1>

<p>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ»ãƒã‚¦ã‚¹ãƒ»ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ã®çµ±åˆå‡¦ç†ã‚’æä¾›ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ éä¾å­˜ãªå…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ ã®åŸºç›¤ã¨ãªã‚Šã¾ã™ã€‚</p>
<h2 id="æ¦‚è¦">æ¦‚è¦</h2>
<p>KeyboardInputã¯ã€VaNillaã‚¨ãƒ³ã‚¸ãƒ³ã«ãŠã‘ã‚‹ä½ãƒ¬ãƒ™ãƒ«å…¥åŠ›å‡¦ç†ã®ä¸­æ ¸ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã€ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ã€ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒœã‚¿ãƒ³ã‚’çµ±ä¸€çš„ã«æ‰±ã„ã€ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ™ãƒ¼ã‚¹ã®å…¥åŠ›çŠ¶æ…‹ç®¡ç†ã«ã‚ˆã‚Šã€æ­£ç¢ºã§å¿œç­”æ€§ã®é«˜ã„å…¥åŠ›å‡¦ç†ã‚’å®Ÿç¾ã—ã¾ã™ã€‚</p>
<h2 id="apiãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹">APIãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹</h2>
<p>è©³ç´°ãªAPIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯<a href="https://endlessshirafu.github.io/VaNillaEngineApiDocuments/api/VaNilla.KeyboardInput.html">VaNilla KeyboardInput APIãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹</a>ã‚’ã”è¦§ãã ã•ã„ã€‚</p>
<h2 id="ä¸»è¦æ©Ÿèƒ½">ä¸»è¦æ©Ÿèƒ½</h2>
<h3 id="åŒ…æ‹¬çš„ãªå…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œ">åŒ…æ‹¬çš„ãªå…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œ</h3>
<ul>
<li><strong>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰</strong>: æ–‡å­—ã‚­ãƒ¼ã€ãƒ•ã‚¡ãƒ³ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¼ã€ä¿®é£¾ã‚­ãƒ¼ã€ç‰¹æ®Šã‚­ãƒ¼ã®å®Œå…¨ã‚µãƒãƒ¼ãƒˆ</li>
<li><strong>ãƒã‚¦ã‚¹</strong>: å·¦ãƒ»å³ãƒ»ä¸­ãƒœã‚¿ãƒ³ã€æ‹¡å¼µãƒœã‚¿ãƒ³ï¼ˆMouse0-Mouse6ï¼‰</li>
<li><strong>ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯</strong>: æœ€å¤§8å°ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã€å„20ãƒœã‚¿ãƒ³å¯¾å¿œ</li>
<li><strong>çµ±ä¸€API</strong>: å…¨ãƒ‡ãƒã‚¤ã‚¹ã‚’åŒä¸€ã®KeyCodeã‚·ã‚¹ãƒ†ãƒ ã§çµ±åˆç®¡ç†</li>
</ul>
<h3 id="ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ™ãƒ¼ã‚¹çŠ¶æ…‹ç®¡ç†">ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ™ãƒ¼ã‚¹çŠ¶æ…‹ç®¡ç†</h3>
<ul>
<li><strong>JustDown</strong>: ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸç¬é–“ã®ã¿trueï¼ˆ1ãƒ•ãƒ¬ãƒ¼ãƒ é™å®šï¼‰</li>
<li><strong>Down</strong>: ã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹é–“ãšã£ã¨trueï¼ˆé€£ç¶šåˆ¤å®šï¼‰</li>
<li><strong>JustUp</strong>: ã‚­ãƒ¼ãŒé›¢ã•ã‚ŒãŸç¬é–“ã®ã¿trueï¼ˆ1ãƒ•ãƒ¬ãƒ¼ãƒ é™å®šï¼‰</li>
<li><strong>çŠ¶æ…‹è¿½è·¡</strong>: ç¾ãƒ•ãƒ¬ãƒ¼ãƒ ã¨å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’æ¯”è¼ƒã—ãŸæ­£ç¢ºãªåˆ¤å®š</li>
</ul>
<h3 id="ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æŠ½è±¡åŒ–">ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æŠ½è±¡åŒ–</h3>
<ul>
<li><strong>DxLib</strong>: é«˜é€Ÿãªãƒãƒ«ã‚¯çŠ¶æ…‹å–å¾—ã«ã‚ˆã‚‹æœ€é©åŒ–</li>
<li><strong>Unity</strong>: Unityæ¨™æº–å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ ã¨ã®å®Œå…¨çµ±åˆ</li>
<li><strong>ä¸€è²«æ€§</strong>: ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ é–“ã§ã®å‹•ä½œå·®ç•°ã‚’æœ€å°åŒ–</li>
</ul>
<h2 id="ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£">ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£</h2>
<h3 id="ä¸­æ ¸ã‚¯ãƒ©ã‚¹">ä¸­æ ¸ã‚¯ãƒ©ã‚¹</h3>
<h4 id="keyboardinputé™çš„ã‚¯ãƒ©ã‚¹">KeyboardInputï¼ˆé™çš„ã‚¯ãƒ©ã‚¹ï¼‰</h4>
<p>ã‚°ãƒ­ãƒ¼ãƒãƒ«å…¥åŠ›å‡¦ç†ã®ä¸­å¤®ç®¡ç†ã‚¯ãƒ©ã‚¹ã§ã™ã€‚</p>
<pre><code class="lang-csharp">public static class KeyboardInput
{
    // åˆæœŸåŒ–ãƒ»æ›´æ–°
    public static void Initialize();
    public static void UpdateKeyState();
    
    // å…¥åŠ›åˆ¤å®š
    public static bool JustDown(KeyCode keyCode);
    public static bool Down(KeyCode keyCode);
    public static bool JustUp(KeyCode keyCode);
}
</code></pre>
<p><strong>ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰:</strong></p>
<ul>
<li><code>Initialize()</code>: å†…éƒ¨çŠ¶æ…‹ã®åˆæœŸåŒ–</li>
<li><code>UpdateKeyState()</code>: ãƒ•ãƒ¬ãƒ¼ãƒ æ¯ã®çŠ¶æ…‹æ›´æ–°ï¼ˆå¿…é ˆå‘¼ã³å‡ºã—ï¼‰</li>
<li><code>JustDown()</code>: ã‚­ãƒ¼æŠ¼ä¸‹ã®ç¬é–“åˆ¤å®š</li>
<li><code>Down()</code>: ã‚­ãƒ¼ä¿æŒçŠ¶æ…‹ã®åˆ¤å®š</li>
<li><code>JustUp()</code>: ã‚­ãƒ¼é›¢æ”¾ã®ç¬é–“åˆ¤å®š</li>
</ul>
<h4 id="keyboardinputcomponent">KeyboardInputComponent</h4>
<p>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘å…¥åŠ›å‡¦ç†ã®ExpresserComponentã§ã™ã€‚</p>
<pre><code class="lang-csharp">public class KeyboardInputComponent : IExpresserComponent
{
    public bool JustDown(KeyCode keyCode);
    public bool Down(KeyCode keyCode);
    public bool JustUp(KeyCode keyCode);
}
</code></pre>
<p><strong>ç‰¹å¾´:</strong></p>
<ul>
<li>é™çš„ã‚¯ãƒ©ã‚¹ã¨åŒä¸€ã®APIã‚’æä¾›</li>
<li>VaNillaã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚·ã‚¹ãƒ†ãƒ ã¨ã®å®Œå…¨çµ±åˆ</li>
<li>ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå˜ä½ã§ã®å…¥åŠ›ç®¡ç†ãŒå¯èƒ½</li>
</ul>
<h4 id="keycodeåˆ—æŒ™å‹">KeyCodeåˆ—æŒ™å‹</h4>
<p>335ç¨®é¡ä»¥ä¸Šã®å…¥åŠ›ã‚³ãƒ¼ãƒ‰ã‚’å®šç¾©ã—ãŸåŒ…æ‹¬çš„ãªåˆ—æŒ™å‹ã§ã™ã€‚</p>
<pre><code class="lang-csharp">public enum KeyCode
{
    // åŸºæœ¬ã‚­ãƒ¼
    A, B, C, /* ... */ Z,
    Alpha0, Alpha1, /* ... */ Alpha9,
    
    // ãƒ•ã‚¡ãƒ³ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¼
    F1, F2, /* ... */ F15,
    
    // ç‰¹æ®Šã‚­ãƒ¼
    Space, Enter, Escape, Tab, Backspace,
    LeftArrow, RightArrow, UpArrow, DownArrow,
    
    // ä¿®é£¾ã‚­ãƒ¼
    LeftShift, RightShift, LeftControl, RightControl,
    LeftAlt, RightAlt, LeftWindows, RightWindows,
    
    // ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³
    Mouse0, Mouse1, Mouse2, Mouse3, Mouse4, Mouse5, Mouse6,
    
    // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒœã‚¿ãƒ³
    JoystickButton0, /* ... */ JoystickButton19,        // ç¬¬1ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
    Joystick1Button0, /* ... */ Joystick1Button19,      // ç¬¬2ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
    /* ... */
    Joystick8Button0, /* ... */ Joystick8Button19,      // ç¬¬8ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
    
    // ç‰¹æ®Šå€¤
    None = 0
}
</code></pre>
<h3 id="ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å®Ÿè£…">ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å®Ÿè£…</h3>
<h4 id="dxlibå®Ÿè£…é«˜æ€§èƒ½ç‰¹åŒ–">DxLibå®Ÿè£…ï¼ˆé«˜æ€§èƒ½ç‰¹åŒ–ï¼‰</h4>
<pre><code class="lang-csharp">// DxLib/KeyboardInputNative.cs
public static void UpdateKeyState()
{
    // å…¨ã‚­ãƒ¼çŠ¶æ…‹ã‚’ä¸€æ‹¬å–å¾—ï¼ˆé«˜é€Ÿï¼‰
    DX.GetHitKeyStateAll(keyState);
    
    // VaNilla KeyCodeã‹ã‚‰DxLibã‚­ãƒ¼ã‚³ãƒ¼ãƒ‰ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°
    UpdateMappedStates();
}
</code></pre>
<p><strong>ç‰¹å¾´:</strong></p>
<ul>
<li><code>DX.GetHitKeyStateAll()</code>ã«ã‚ˆã‚‹ä¸€æ‹¬çŠ¶æ…‹å–å¾—</li>
<li>æœ€å°é™ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã«ã‚ˆã‚‹é«˜é€Ÿå‡¦ç†</li>
<li>DxLibå¯¾å¿œç¯„å›²å†…ã®ã‚­ãƒ¼ã®ã¿ã‚µãƒãƒ¼ãƒˆ</li>
<li>ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚²ãƒ¼ãƒ é–‹ç™ºã«æœ€é©åŒ–</li>
</ul>
<h4 id="unityå®Ÿè£…å®Œå…¨äº’æ›">Unityå®Ÿè£…ï¼ˆå®Œå…¨äº’æ›ï¼‰</h4>
<pre><code class="lang-csharp">// Unity/KeyboardInputNative.cs
public static bool GetKey(KeyCode vanillaKeyCode)
{
    var unityKeyCode = ConvertToUnityKeyCode(vanillaKeyCode);
    return UnityEngine.Input.GetKey(unityKeyCode);
}
</code></pre>
<p><strong>ç‰¹å¾´:</strong></p>
<ul>
<li>Unityæ¨™æº–å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ ã¨ã®å®Œå…¨çµ±åˆ</li>
<li>å…¨KeyCodeç¯„å›²ã®å®Œå…¨ã‚µãƒãƒ¼ãƒˆ</li>
<li>Unityã‚¨ãƒ‡ã‚£ã‚¿ã§ã®ãƒ‡ãƒãƒƒã‚°æ”¯æ´</li>
<li>ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å±•é–‹ã«å¯¾å¿œ</li>
</ul>
<h2 id="åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•">åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•</h2>
<h3 id="ã‚°ãƒ­ãƒ¼ãƒãƒ«å…¥åŠ›å‡¦ç†">ã‚°ãƒ­ãƒ¼ãƒãƒ«å…¥åŠ›å‡¦ç†</h3>
<pre><code class="lang-csharp">public class GameInputManager
{
    public void Initialize()
    {
        // å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
        VaNilla.KeyboardInput.Initialize();
    }
    
    public void Update()
    {
        // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å¿…é ˆï¼šå…¥åŠ›çŠ¶æ…‹ã®æ›´æ–°
        VaNilla.KeyboardInput.UpdateKeyState();
        
        // ã‚²ãƒ¼ãƒ å…¥åŠ›ã®å‡¦ç†
        HandlePlayerInput();
        HandleUIInput();
    }
    
    private void HandlePlayerInput()
    {
        // ç¬é–“çš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚¸ãƒ£ãƒ³ãƒ—ã€æ”»æ’ƒç­‰ï¼‰
        if (VaNilla.KeyboardInput.JustDown(KeyCode.Space))
        {
            player.Jump();
        }
        
        // ç¶™ç¶šçš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆç§»å‹•ç­‰ï¼‰
        if (VaNilla.KeyboardInput.Down(KeyCode.LeftArrow))
        {
            player.MoveLeft();
        }
        
        if (VaNilla.KeyboardInput.Down(KeyCode.RightArrow))
        {
            player.MoveRight();
        }
        
        // ã‚­ãƒ¼é›¢ã—æ¤œå‡ºï¼ˆãƒãƒ£ãƒ¼ã‚¸æ”»æ’ƒç­‰ï¼‰
        if (VaNilla.KeyboardInput.JustUp(KeyCode.Z))
        {
            player.ReleaseChargedAttack();
        }
    }
    
    private void HandleUIInput()
    {
        // ãƒ¡ãƒ‹ãƒ¥ãƒ¼æ“ä½œ
        if (VaNilla.KeyboardInput.JustDown(KeyCode.Escape))
        {
            TogglePauseMenu();
        }
        
        // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ï¼ˆè‹±æ•°å­—ï¼‰
        for (KeyCode key = KeyCode.A; key &lt;= KeyCode.Z; key++)
        {
            if (VaNilla.KeyboardInput.JustDown(key))
            {
                AddCharacterToInput(key.ToString());
            }
        }
    }
}
</code></pre>
<h3 id="ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ™ãƒ¼ã‚¹å…¥åŠ›å‡¦ç†">ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ™ãƒ¼ã‚¹å…¥åŠ›å‡¦ç†</h3>
<pre><code class="lang-csharp">public class ControllablePlayer : Object
{
    public override void SetUp()
    {
        // KeyboardInputComponentã®è¿½åŠ 
        this.AddComponent(new KeyboardInputComponent());
    }
    
    public override void Execute()
    {
        var input = this.GetComponent&lt;KeyboardInputComponent&gt;();
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å›ºæœ‰ã®å…¥åŠ›å‡¦ç†
        HandleMovement(input);
        HandleActions(input);
    }
    
    private void HandleMovement(KeyboardInputComponent input)
    {
        var movement = Vector2.Zero;
        
        // WASDç§»å‹•
        if (input.Down(KeyCode.W)) movement.Y += 1;
        if (input.Down(KeyCode.S)) movement.Y -= 1;
        if (input.Down(KeyCode.A)) movement.X -= 1;
        if (input.Down(KeyCode.D)) movement.X += 1;
        
        // æ–œã‚ç§»å‹•ã®æ­£è¦åŒ–
        if (movement.Length &gt; 0)
        {
            movement = movement.Normalized * moveSpeed;
            this.GetComponent&lt;HasVelocity&gt;().Velocity = movement;
        }
    }
    
    private void HandleActions(KeyboardInputComponent input)
    {
        // å„ç¨®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        if (input.JustDown(KeyCode.Space)) TriggerJump();
        if (input.JustDown(KeyCode.X)) TriggerAttack();
        if (input.JustDown(KeyCode.Z)) TriggerSpecialAction();
        
        // ã‚¬ãƒ¼ãƒ‰ï¼ˆæŠ¼ã—ã¦ã„ã‚‹é–“æœ‰åŠ¹ï¼‰
        if (input.Down(KeyCode.LeftShift))
        {
            ActivateGuard();
        }
        else
        {
            DeactivateGuard();
        }
    }
}
</code></pre>
<h2 id="é«˜åº¦ãªä½¿ç”¨ä¾‹">é«˜åº¦ãªä½¿ç”¨ä¾‹</h2>
<h3 id="ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¥åŠ›ç®¡ç†">ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¥åŠ›ç®¡ç†</h3>
<pre><code class="lang-csharp">public class MultiPlayerInputManager
{
    private Dictionary&lt;int, PlayerInputConfig&gt; playerConfigs;
    
    public struct PlayerInputConfig
    {
        public KeyCode Up, Down, Left, Right;
        public KeyCode Attack, Jump, Special;
        public KeyCode[] JoystickButtons; // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ç”¨
    }
    
    public void InitializePlayers()
    {
        playerConfigs = new Dictionary&lt;int, PlayerInputConfig&gt;
        {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼‰
            [1] = new PlayerInputConfig
            {
                Up = KeyCode.W, Down = KeyCode.S, 
                Left = KeyCode.A, Right = KeyCode.D,
                Attack = KeyCode.X, Jump = KeyCode.Space, Special = KeyCode.Z
            },
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ï¼ˆã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯1ï¼‰
            [2] = new PlayerInputConfig
            {
                Up = KeyCode.JoystickButton0,     // ä¸Šæ–¹å‘
                Down = KeyCode.JoystickButton1,   // ä¸‹æ–¹å‘
                Left = KeyCode.JoystickButton2,   // å·¦æ–¹å‘
                Right = KeyCode.JoystickButton3,  // å³æ–¹å‘
                Attack = KeyCode.JoystickButton4, // ãƒœã‚¿ãƒ³1
                Jump = KeyCode.JoystickButton5,   // ãƒœã‚¿ãƒ³2
                Special = KeyCode.JoystickButton6 // ãƒœã‚¿ãƒ³3
            }
        };
    }
    
    public void UpdatePlayers()
    {
        foreach (var (playerId, config) in playerConfigs)
        {
            UpdatePlayer(playerId, config);
        }
    }
    
    private void UpdatePlayer(int playerId, PlayerInputConfig config)
    {
        var player = GetPlayer(playerId);
        
        // ç§»å‹•å‡¦ç†
        var movement = Vector2.Zero;
        if (VaNilla.KeyboardInput.Down(config.Up)) movement.Y += 1;
        if (VaNilla.KeyboardInput.Down(config.Down)) movement.Y -= 1;
        if (VaNilla.KeyboardInput.Down(config.Left)) movement.X -= 1;
        if (VaNilla.KeyboardInput.Down(config.Right)) movement.X += 1;
        
        player.SetMovement(movement);
        
        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
        if (VaNilla.KeyboardInput.JustDown(config.Attack)) player.Attack();
        if (VaNilla.KeyboardInput.JustDown(config.Jump)) player.Jump();
        if (VaNilla.KeyboardInput.JustDown(config.Special)) player.SpecialAction();
    }
}
</code></pre>
<h3 id="é«˜åº¦ãªã‚­ãƒ¼å…¥åŠ›å‡¦ç†">é«˜åº¦ãªã‚­ãƒ¼å…¥åŠ›å‡¦ç†</h3>
<pre><code class="lang-csharp">public class AdvancedInputHandler
{
    private Dictionary&lt;KeyCode, float&gt; keyHoldTimes = new();
    private Dictionary&lt;string, List&lt;KeyCode&gt;&gt; inputSequences = new();
    
    public void Update()
    {
        UpdateKeyHoldTimes();
        CheckInputSequences();
        CheckKeyCombinaisons();
    }
    
    private void UpdateKeyHoldTimes()
    {
        // ã‚­ãƒ¼ä¿æŒæ™‚é–“ã®è¿½è·¡
        foreach (KeyCode key in Enum.GetValues&lt;KeyCode&gt;())
        {
            if (key == KeyCode.None) continue;
            
            if (VaNilla.KeyboardInput.Down(key))
            {
                if (!keyHoldTimes.ContainsKey(key))
                    keyHoldTimes[key] = 0;
                
                keyHoldTimes[key] += TimeManager.DeltaTime;
                
                // é•·æŠ¼ã—åˆ¤å®šï¼ˆ2ç§’ä»¥ä¸Šï¼‰
                if (keyHoldTimes[key] &gt;= 2.0f &amp;&amp; keyHoldTimes[key] - TimeManager.DeltaTime &lt; 2.0f)
                {
                    OnKeyLongPress(key);
                }
            }
            else
            {
                if (keyHoldTimes.ContainsKey(key))
                {
                    OnKeyRelease(key, keyHoldTimes[key]);
                    keyHoldTimes.Remove(key);
                }
            }
        }
    }
    
    private void CheckInputSequences()
    {
        // ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ã®æ¤œå‡ºï¼ˆæ ¼é—˜ã‚²ãƒ¼ãƒ é¢¨ï¼‰
        var commands = new Dictionary&lt;string, KeyCode[]&gt;
        {
            [&quot;hadoken&quot;] = new[] { KeyCode.DownArrow, KeyCode.RightArrow, KeyCode.X },
            [&quot;shoryuken&quot;] = new[] { KeyCode.RightArrow, KeyCode.DownArrow, KeyCode.RightArrow, KeyCode.Z },
            [&quot;konami&quot;] = new[] { 
                KeyCode.UpArrow, KeyCode.UpArrow, 
                KeyCode.DownArrow, KeyCode.DownArrow,
                KeyCode.LeftArrow, KeyCode.RightArrow, 
                KeyCode.LeftArrow, KeyCode.RightArrow,
                KeyCode.B, KeyCode.A 
            }
        };
        
        foreach (var (commandName, sequence) in commands)
        {
            if (CheckSequence(commandName, sequence))
            {
                ExecuteCommand(commandName);
            }
        }
    }
    
    private void CheckKeyCombinaisons()
    {
        // åŒæ™‚æŠ¼ã—åˆ¤å®š
        if (VaNilla.KeyboardInput.Down(KeyCode.LeftControl) &amp;&amp; 
            VaNilla.KeyboardInput.JustDown(KeyCode.S))
        {
            SaveGame(); // Ctrl+S
        }
        
        if (VaNilla.KeyboardInput.Down(KeyCode.LeftControl) &amp;&amp; 
            VaNilla.KeyboardInput.JustDown(KeyCode.Z))
        {
            UndoAction(); // Ctrl+Z
        }
        
        // ä¸‰é‡åŒæ™‚æŠ¼ã—
        if (VaNilla.KeyboardInput.Down(KeyCode.LeftControl) &amp;&amp; 
            VaNilla.KeyboardInput.Down(KeyCode.LeftShift) &amp;&amp; 
            VaNilla.KeyboardInput.JustDown(KeyCode.Escape))
        {
            ForceQuit(); // Ctrl+Shift+Esc
        }
    }
    
    private bool CheckSequence(string commandName, KeyCode[] sequence)
    {
        if (!inputSequences.ContainsKey(commandName))
            inputSequences[commandName] = new List&lt;KeyCode&gt;();
        
        var currentSequence = inputSequences[commandName];
        
        // æ–°ã—ã„å…¥åŠ›ã‚’ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«è¿½åŠ 
        foreach (KeyCode key in sequence)
        {
            if (VaNilla.KeyboardInput.JustDown(key))
            {
                // æ­£ã—ã„é †åºã‹ãƒã‚§ãƒƒã‚¯
                if (currentSequence.Count &lt; sequence.Length &amp;&amp; 
                    sequence[currentSequence.Count] == key)
                {
                    currentSequence.Add(key);
                    
                    // ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å®Œæˆãƒã‚§ãƒƒã‚¯
                    if (currentSequence.Count == sequence.Length)
                    {
                        currentSequence.Clear();
                        return true;
                    }
                }
                else
                {
                    // é–“é•ã£ãŸå…¥åŠ›ã§ãƒªã‚»ãƒƒãƒˆ
                    currentSequence.Clear();
                    
                    // æœ€åˆã®ã‚­ãƒ¼ã¨ä¸€è‡´ã™ã‚‹å ´åˆã¯è¿½åŠ 
                    if (sequence[0] == key)
                    {
                        currentSequence.Add(key);
                    }
                }
                break;
            }
        }
        
        return false;
    }
}
</code></pre>
<h3 id="ãƒ‡ãƒãƒƒã‚°ã¨ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°">ãƒ‡ãƒãƒƒã‚°ã¨ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°</h3>
<pre><code class="lang-csharp">public class InputDebugger
{
    private Dictionary&lt;KeyCode, InputStats&gt; keyStats = new();
    
    public struct InputStats
    {
        public int PressCount;
        public float TotalHoldTime;
        public float LastPressTime;
    }
    
    public void Update()
    {
        // å…¨ã‚­ãƒ¼ã®çµ±è¨ˆæƒ…å ±æ›´æ–°
        foreach (KeyCode key in Enum.GetValues&lt;KeyCode&gt;())
        {
            if (key == KeyCode.None) continue;
            
            if (!keyStats.ContainsKey(key))
                keyStats[key] = new InputStats();
            
            var stats = keyStats[key];
            
            if (VaNilla.KeyboardInput.JustDown(key))
            {
                stats.PressCount++;
                stats.LastPressTime = TimeManager.TotalTime;
            }
            
            if (VaNilla.KeyboardInput.Down(key))
            {
                stats.TotalHoldTime += TimeManager.DeltaTime;
            }
            
            keyStats[key] = stats;
        }
    }
    
    public void LogInputStatistics()
    {
        VaNilla.Debug.Logger.LogInfo(&quot;=== Input Statistics ===&quot;);
        
        var sortedStats = keyStats
            .Where(kvp =&gt; kvp.Value.PressCount &gt; 0)
            .OrderByDescending(kvp =&gt; kvp.Value.PressCount)
            .Take(10);
        
        foreach (var (key, stats) in sortedStats)
        {
            VaNilla.Debug.Logger.LogInfo(
                $&quot;{key}: {stats.PressCount} presses, &quot; +
                $&quot;{stats.TotalHoldTime:F2}s total hold time&quot;);
        }
    }
    
    public void ShowCurrentInputState()
    {
        var activeKeys = new List&lt;KeyCode&gt;();
        
        foreach (KeyCode key in Enum.GetValues&lt;KeyCode&gt;())
        {
            if (key == KeyCode.None) continue;
            
            if (VaNilla.KeyboardInput.Down(key))
            {
                activeKeys.Add(key);
            }
        }
        
        if (activeKeys.Count &gt; 0)
        {
            var keyString = string.Join(&quot;, &quot;, activeKeys);
            VaNilla.Debug.Logger.LogInfo($&quot;Active keys: {keyString}&quot;);
        }
    }
    
    public bool ValidateInputSystem()
    {
        // å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
        try
        {
            VaNilla.KeyboardInput.UpdateKeyState();
            
            // åŸºæœ¬ã‚­ãƒ¼ã®å‹•ä½œç¢ºèª
            var testResult = VaNilla.KeyboardInput.Down(KeyCode.None);
            
            VaNilla.Debug.Logger.LogInfo(&quot;Input system validation passed&quot;);
            return true;
        }
        catch (Exception ex)
        {
            VaNilla.Debug.Logger.LogError($&quot;Input system validation failed: {ex.Message}&quot;);
            return false;
        }
    }
}
</code></pre>
<h2 id="keyconfigã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆ">KeyConfigã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆ</h2>
<pre><code class="lang-csharp">public class IntegratedInputSystem
{
    public void InitializeWithKeyConfig()
    {
        // 1. KeyboardInputã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
        VaNilla.KeyboardInput.Initialize();
        
        // 2. KeyConfigã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
        if (!VaNilla.KeyConfig.IsExistConfig())
        {
            VaNilla.KeyConfig.InitConfig();
        }
        VaNilla.KeyConfig.LoadConfig();
        
        VaNilla.Debug.Logger.LogInfo(&quot;Integrated input system initialized&quot;);
    }
    
    public void HandleGameInput()
    {
        // KeyConfigã‚’é€šã˜ãŸæŠ½è±¡åŒ–ã•ã‚ŒãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³åˆ¤å®š
        if (IsActionTriggered(KeyConfig.Action.Decide))
        {
            HandleDecideAction();
        }
        
        if (IsActionTriggered(KeyConfig.Action.Cancel))
        {
            HandleCancelAction();
        }
        
        // æ–¹å‘å…¥åŠ›ã®å‡¦ç†
        var movement = GetMovementInput();
        if (movement.Length &gt; 0)
        {
            HandleMovement(movement);
        }
    }
    
    private bool IsActionTriggered(KeyConfig.Action action)
    {
        // KeyConfigã‹ã‚‰å®Ÿéš›ã®ã‚­ãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—
        var keyCode = VaNilla.KeyConfig.GetKeyboardInput(action);
        
        // KeyboardInputã§å®Ÿéš›ã®åˆ¤å®š
        return VaNilla.KeyboardInput.JustDown(keyCode);
    }
    
    private Vector2 GetMovementInput()
    {
        var movement = Vector2.Zero;
        
        // KeyConfigã‹ã‚‰ã®ç§»å‹•ã‚­ãƒ¼å–å¾—ã¨åˆ¤å®š
        if (VaNilla.KeyboardInput.Down(VaNilla.KeyConfig.GetKeyboardInput(KeyConfig.Action.MoveUp)))
            movement.Y += 1;
        if (VaNilla.KeyboardInput.Down(VaNilla.KeyConfig.GetKeyboardInput(KeyConfig.Action.MoveDown)))
            movement.Y -= 1;
        if (VaNilla.KeyboardInput.Down(VaNilla.KeyConfig.GetKeyboardInput(KeyConfig.Action.MoveLeft)))
            movement.X -= 1;
        if (VaNilla.KeyboardInput.Down(VaNilla.KeyConfig.GetKeyboardInput(KeyConfig.Action.MoveRight)))
            movement.X += 1;
        
        return movement.Normalized;
    }
}
</code></pre>
<h2 id="ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–</h2>
<h3 id="åŠ¹ç‡çš„ãªå…¥åŠ›å‡¦ç†">åŠ¹ç‡çš„ãªå…¥åŠ›å‡¦ç†</h3>
<pre><code class="lang-csharp">public class OptimizedInputProcessor
{
    private HashSet&lt;KeyCode&gt; trackedKeys = new();
    private Dictionary&lt;KeyCode, bool&gt; cachedStates = new();
    
    public void RegisterKey(KeyCode key)
    {
        // å¿…è¦ãªã‚­ãƒ¼ã®ã¿ã‚’ç™»éŒ²ã—ã¦å‡¦ç†è² è·ã‚’è»½æ¸›
        trackedKeys.Add(key);
    }
    
    public void OptimizedUpdate()
    {
        // ç™»éŒ²ã•ã‚ŒãŸã‚­ãƒ¼ã®ã¿ã‚’å‡¦ç†
        foreach (var key in trackedKeys)
        {
            bool currentState = VaNilla.KeyboardInput.Down(key);
            bool previousState = cachedStates.GetValueOrDefault(key, false);
            
            // çŠ¶æ…‹å¤‰åŒ–ãŒã‚ã£ãŸå ´åˆã®ã¿å‡¦ç†
            if (currentState != previousState)
            {
                if (currentState)
                    OnKeyDown(key);
                else
                    OnKeyUp(key);
                
                cachedStates[key] = currentState;
            }
        }
    }
    
    // ãƒãƒƒãƒå‡¦ç†ã«ã‚ˆã‚‹é«˜é€ŸåŒ–
    public bool AnyKeyPressed(params KeyCode[] keys)
    {
        // è¤‡æ•°ã‚­ãƒ¼ã®ä¸€æ‹¬åˆ¤å®š
        foreach (var key in keys)
        {
            if (VaNilla.KeyboardInput.Down(key))
                return true;
        }
        return false;
    }
    
    public bool AllKeysPressed(params KeyCode[] keys)
    {
        // å…¨ã‚­ãƒ¼åŒæ™‚æŠ¼ã—åˆ¤å®š
        foreach (var key in keys)
        {
            if (!VaNilla.KeyboardInput.Down(key))
                return false;
        }
        return true;
    }
}
</code></pre>
<h3 id="ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ã®æ”¹å–„">ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ã®æ”¹å–„</h3>
<pre><code class="lang-csharp">public class EfficientInputManager
{
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«ã«ã‚ˆã‚‹åŠ¹ç‡åŒ–
    private Queue&lt;InputEvent&gt; eventPool = new();
    private List&lt;InputEvent&gt; activeEvents = new();
    
    public struct InputEvent
    {
        public KeyCode Key;
        public InputEventType Type;
        public float Timestamp;
    }
    
    public enum InputEventType
    {
        KeyDown, KeyUp, KeyHold
    }
    
    public void ProcessInputEvents()
    {
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒ—ãƒ¼ãƒ«ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†åˆ©ç”¨
        foreach (KeyCode key in trackedKeys)
        {
            if (VaNilla.KeyboardInput.JustDown(key))
            {
                var inputEvent = GetPooledEvent();
                inputEvent.Key = key;
                inputEvent.Type = InputEventType.KeyDown;
                inputEvent.Timestamp = TimeManager.TotalTime;
                activeEvents.Add(inputEvent);
            }
            
            if (VaNilla.KeyboardInput.JustUp(key))
            {
                var inputEvent = GetPooledEvent();
                inputEvent.Key = key;
                inputEvent.Type = InputEventType.KeyUp;
                inputEvent.Timestamp = TimeManager.TotalTime;
                activeEvents.Add(inputEvent);
            }
        }
        
        // å¤ã„ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒ—ãƒ¼ãƒ«ã«è¿”å´
        ReturnExpiredEventsToPool();
    }
    
    private InputEvent GetPooledEvent()
    {
        if (eventPool.Count &gt; 0)
        {
            return eventPool.Dequeue();
        }
        return new InputEvent();
    }
    
    private void ReturnExpiredEventsToPool()
    {
        for (int i = activeEvents.Count - 1; i &gt;= 0; i--)
        {
            if (TimeManager.TotalTime - activeEvents[i].Timestamp &gt; 1.0f)
            {
                eventPool.Enqueue(activeEvents[i]);
                activeEvents.RemoveAt(i);
            }
        }
    }
}
</code></pre>
<h2 id="ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œçŠ¶æ³">ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œçŠ¶æ³</h2>
<table>
<thead>
<tr>
<th>æ©Ÿèƒ½</th>
<th>DxLib</th>
<th>Unity</th>
<th>å‚™è€ƒ</th>
</tr>
</thead>
<tbody>
<tr>
<td>åŸºæœ¬ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›</td>
<td>âœ…</td>
<td>âœ…</td>
<td>å®Œå…¨å¯¾å¿œ</td>
</tr>
<tr>
<td>ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³</td>
<td>âœ…</td>
<td>âœ…</td>
<td>Mouse0-6å¯¾å¿œ</td>
</tr>
<tr>
<td>ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯1-4</td>
<td>âœ…</td>
<td>âœ…</td>
<td>åŸºæœ¬4å°å¯¾å¿œ</td>
</tr>
<tr>
<td>ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯5-8</td>
<td>âŒ</td>
<td>âœ…</td>
<td>Unityæ‹¡å¼µå¯¾å¿œ</td>
</tr>
<tr>
<td>ç‰¹æ®Šã‚­ãƒ¼ï¼ˆPipeç­‰ï¼‰</td>
<td>ğŸ”„</td>
<td>âœ…</td>
<td>ä¸€éƒ¨ãƒãƒƒãƒ”ãƒ³ã‚°å·®ç•°</td>
</tr>
<tr>
<td>ãƒ•ãƒ¬ãƒ¼ãƒ åŒæœŸ</td>
<td>âœ…</td>
<td>âœ…</td>
<td>å®Œå…¨å¯¾å¿œ</td>
</tr>
</tbody>
</table>
<p>âœ… å®Œå…¨å®Ÿè£… / ğŸ”„ åˆ¶é™ã‚ã‚Š / âŒ æœªå¯¾å¿œ</p>
<h2 id="ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ³•">ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ³•</h2>
<h3 id="1-updatekeystateã®å‘¼ã³å¿˜ã‚Œ">1. UpdateKeyState()ã®å‘¼ã³å¿˜ã‚Œ</h3>
<pre><code class="lang-csharp">// å•é¡Œ: å…¥åŠ›ãŒåå¿œã—ãªã„
public void BadUpdate()
{
    // UpdateKeyState()ã‚’å‘¼ã°ãšã«åˆ¤å®š
    if (VaNilla.KeyboardInput.JustDown(KeyCode.Space)) // å¸¸ã«false
    {
        // å®Ÿè¡Œã•ã‚Œãªã„
    }
}

// è§£æ±º: å¿…ãšUpdateKeyState()ã‚’æœ€åˆã«å‘¼ã¶
public void GoodUpdate()
{
    VaNilla.KeyboardInput.UpdateKeyState(); // å¿…é ˆï¼
    
    if (VaNilla.KeyboardInput.JustDown(KeyCode.Space))
    {
        // æ­£å¸¸ã«å‹•ä½œ
    }
}
</code></pre>
<h3 id="2-justdownã¨downã®ä½¿ã„åˆ†ã‘">2. JustDownã¨Downã®ä½¿ã„åˆ†ã‘</h3>
<pre><code class="lang-csharp">// å•é¡Œ: ã‚¸ãƒ£ãƒ³ãƒ—ãŒé€£ç¶šç™ºå‹•
public void BadJump()
{
    if (VaNilla.KeyboardInput.Down(KeyCode.Space)) // Downä½¿ç”¨
    {
        player.Jump(); // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å‘¼ã°ã‚Œã‚‹
    }
}

// è§£æ±º: ç¬é–“åˆ¤å®šã«ã¯JustDownã‚’ä½¿ç”¨
public void GoodJump()
{
    if (VaNilla.KeyboardInput.JustDown(KeyCode.Space)) // JustDownä½¿ç”¨
    {
        player.Jump(); // 1å›ã ã‘å‘¼ã°ã‚Œã‚‹
    }
}
</code></pre>
<h3 id="3-ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å·®ç•°ã®å¯¾å¿œ">3. ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å·®ç•°ã®å¯¾å¿œ</h3>
<pre><code class="lang-csharp">public class CrossPlatformInput
{
    public static bool IsKeySupported(KeyCode key)
    {
        // DxLibã§æœªå¯¾å¿œã®ã‚­ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
        var unsupportedInDxLib = new HashSet&lt;KeyCode&gt;
        {
            KeyCode.Joystick5Button0, // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯5-8
            KeyCode.Pipe,             // ç‰¹æ®Šã‚­ãƒ¼
            // ãã®ä»–...
        };
        
        #if DXLIB_BUILD
        return !unsupportedInDxLib.Contains(key);
        #else
        return true; // Unity ã§ã¯å…¨å¯¾å¿œ
        #endif
    }
}
</code></pre>
<h2 id="ä¾å­˜é–¢ä¿‚">ä¾å­˜é–¢ä¿‚</h2>
<ul>
<li><strong>ExpresserComponent</strong>: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ </li>
<li><strong>Object</strong>: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚·ã‚¹ãƒ†ãƒ çµ±åˆ</li>
<li><strong>TimeManager</strong>: ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“ç®¡ç†</li>
<li><strong>KeyConfig</strong>: ä¸Šä½å…¥åŠ›æŠ½è±¡åŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰</li>
<li><strong>PlayerInput</strong>: é«˜ãƒ¬ãƒ™ãƒ«å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰</li>
</ul>
<h2 id="ã¾ã¨ã‚">ã¾ã¨ã‚</h2>
<p>KeyboardInputã¯ã€VaNillaã‚¨ãƒ³ã‚¸ãƒ³ã«ãŠã‘ã‚‹å…¥åŠ›å‡¦ç†ã®åŸºç›¤ã¨ãªã‚‹é‡è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ã™ã€‚åŒ…æ‹¬çš„ãªãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œã€æ­£ç¢ºãªãƒ•ãƒ¬ãƒ¼ãƒ ãƒ™ãƒ¼ã‚¹åˆ¤å®šã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æŠ½è±¡åŒ–ã«ã‚ˆã‚Šã€ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã®ã‚²ãƒ¼ãƒ ã§ä¿¡é ¼æ€§ã®é«˜ã„å…¥åŠ›å‡¦ç†ã‚’å®Ÿç¾ã—ã¾ã™ã€‚é©åˆ‡ãªä½¿ç”¨ã«ã‚ˆã‚Šã€ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ã§ç›´æ„Ÿçš„ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/EndlessShirafu/VaNilla/blob/develop/Documents/docfx/modules/KeyboardInput/README.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
